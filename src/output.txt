=======================
File: app.d.ts
=======================
// See https://kit.svelte.dev/docs/types#app
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};

=======================
File: app.html
=======================
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>

=======================
File: complete_output.sh
=======================
#!/bin/bash



# Run script1.sh and script2.sh
./show_tree.sh 
./repo_to_txt.sh

# Optional: Clean up individual output files if not needed
rm "./directory_structure.txt"
=======================
File: directory_structure.txt
=======================

.
├── app.d.ts
├── app.html
├── complete_output.sh
├── directory_structure.txt
lib
images
├── github.svg
├── svelte-logo.svg
├── svelte-welcome.png
└── svelte-welcome.webp
├── output.txt
├── repo_to_txt.sh
routes
├── +layout.svelte
├── +page.svelte
├── +page.ts
├── StartMenu.svelte
├── styles.css
└── Taskbar.svelte
├── show_tree.sh
└── window.svelte.ts

=======================
File: output.txt
=======================

=======================
File: repo_to_txt.sh
=======================
#!/bin/bash

# Directory containing the files
DIR="."

# Output file
OUTPUT="output.txt"

# Clear the output file if it exists
> "$OUTPUT"

# Find all files in the directory and subdirectories, excluding certain file types
find "$DIR" -type f ! \( -name '*.svg' -o -name '*.png' -o -name '*.jpg' -o -name '*.jpeg' -o -name '*.webp' -o -name '*.gif' -o -name '*.bmp' \) | while read -r FILE; do
    FILENAME=$(basename "$FILE")
    # Add a banner with the filename
    echo "=======================" >> "$OUTPUT"
    echo "File: $FILENAME" >> "$OUTPUT"
    echo "=======================" >> "$OUTPUT"
    # Append the contents of each file to the output file
    cat "$FILE" >> "$OUTPUT"
    echo >> "$OUTPUT"  # Add a newline for separation
done

echo "All files have been concatenated into $OUTPUT"

=======================
File: +layout.svelte
=======================
<script>
</script>

<div >


	<main>
		<slot />
	</main>


</div>


=======================
File: +page.svelte
=======================
<script lang="ts">
	import { onMount } from 'svelte';
	import Taskbar from './Taskbar.svelte'; // Adjust the path as necessary
	import {
	  setTileElement,
	  setDesktopElement,
	  onMouseDown,
	  onMouseMove,
	  onMouseUp,
	  onResizeMove,
	  onResizeUp,
	  handleMouseLeave
	} from './../window.svelte';
  
	let tile: HTMLDivElement;
	let desktop: HTMLDivElement;
  
	onMount(() => {
	  setTileElement(tile);
	  setDesktopElement(desktop);
  
	  return () => {
		window.removeEventListener('mousemove', onMouseMove);
		window.removeEventListener('mouseup', onMouseUp);
		window.removeEventListener('mousemove', onResizeMove);
		window.removeEventListener('mouseup', onResizeUp);
	  };
	});
  </script>
  
  <div class="desktop" bind:this={desktop} on:mouseleave={handleMouseLeave}>
	<div class="tile" bind:this={tile} on:mousedown={onMouseDown}>
	  <div class="titlebar">Title Bar</div>
	  <div class="body">Tile Body</div>
	  <div class="resize-handle" data-direction="top-left"></div>
	  <div class="resize-handle" data-direction="top-right"></div>
	  <div class="resize-handle" data-direction="bottom-left"></div>
	  <div class="resize-handle" data-direction="bottom-right"></div>
	  <div class="resize-handle" data-direction="top"></div>
	  <div class="resize-handle" data-direction="bottom"></div>
	  <div class="resize-handle" data-direction="left"></div>
	  <div class="resize-handle" data-direction="right"></div>
	</div>
	<Taskbar />
  </div>
  
  <style>
	.desktop {
	  width: 100%;
	  height: 100vh;
	  border: 1px solid #000;
	  position: relative;
	  overflow: hidden;
	}
  
	.tile {
	  width: 200px;
	  height: 200px;
	  background-color: #3498db;
	  position: absolute;
	  top: 0;
	  left: 0;
	  display: flex;
	  flex-direction: column;
	  min-width: 100px; /* Set minimum width */
	  min-height: 100px; /* Set minimum height */
	  max-width: 500px; /* Set maximum width */
	  max-height: 500px; /* Set maximum height */
	}
  
	.titlebar {
	  width: 100%;
	  height: 30px;
	  background-color: #2980b9;
	  cursor: grab;
	  user-select: none; /* Prevent text selection while dragging */
	}
  
	.titlebar:active {
	  cursor: grabbing;
	}
  
	.body {
	  width: 100%;
	  height: calc(100% - 30px);
	  background-color: #ecf0f1;
	  flex: 1;
	}
  
	.resize-handle {
	  position: absolute;
	  background: transparent;
	}
  
	.resize-handle:hover {
	  background: #95a5a6;
	}
  
	.resize-handle[data-direction*='top'] {
	  top: -5px;
	  height: 10px;
	}
  
	.resize-handle[data-direction*='bottom'] {
	  bottom: -5px;
	  height: 10px;
	}
  
	.resize-handle[data-direction*='left'] {
	  left: -5px;
	  width: 10px;
	}
  
	.resize-handle[data-direction*='right'] {
	  right: -5px;
	  width: 10px;
	}
  
	.resize-handle[data-direction='top-left'] {
	  cursor: nwse-resize;
	  width: 10px;
	  height: 10px;
	}
  
	.resize-handle[data-direction='top-right'] {
	  cursor: nesw-resize;
	  width: 10px;
	  height: 10px;
	}
  
	.resize-handle[data-direction='bottom-left'] {
	  cursor: nesw-resize;
	  width: 10px;
	  height: 10px;
	}
  
	.resize-handle[data-direction='bottom-right'] {
	  cursor: nwse-resize;
	  width: 10px;
	  height: 10px;
	}
  
	.resize-handle[data-direction='top'] {
	  cursor: ns-resize;
	  width: 100%;
	}
  
	.resize-handle[data-direction='bottom'] {
	  cursor: ns-resize;
	  width: 100%;
	}
  
	.resize-handle[data-direction='left'] {
	  cursor: ew-resize;
	  height: 100%;
	}
  
	.resize-handle[data-direction='right'] {
	  cursor: ew-resize;
	  height: 100%;
	}
  </style>
  
=======================
File: +page.ts
=======================
// since there's no dynamic data here, we can prerender
// it so that it gets served as a static asset in production
export const prerender = true;

=======================
File: StartMenu.svelte
=======================
<script lang="ts">
    export let visible: boolean = false;
  </script>
  
  <style>
    .start-menu {
      position: absolute;
      bottom: 40px; /* Adjust based on the height of the taskbar */
      left: 10px;
      width: 200px;
      background-color: white;
      border: 1px solid #ccc;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      display: none;
    }
  
    .start-menu.visible {
      display: block;
    }
  </style>
  
  <div class="start-menu {visible ? 'visible' : ''}">
    <!-- Start menu content goes here -->
    <div>Item 1</div>
    <div>Item 2</div>
    <div>Item 3</div>
  </div>
  
=======================
File: styles.css
=======================

=======================
File: Taskbar.svelte
=======================
<script lang="ts">
    import { onMount } from 'svelte';
    import StartMenu from './StartMenu.svelte';
  
    let isStartMenuVisible: boolean = false;
  
    function toggleStartMenu(): void {
      isStartMenuVisible = !isStartMenuVisible;
    }
  
    function handleClickOutside(event: MouseEvent): void {
      const startMenu = document.querySelector('.start-menu') as HTMLElement;
      const startButton = document.querySelector('.start-button') as HTMLElement;
  
      if (startMenu && startButton && !startMenu.contains(event.target as Node) && !startButton.contains(event.target as Node)) {
        isStartMenuVisible = false;
      }
    }
  
    onMount((): () => void => {
      document.addEventListener('click', handleClickOutside);
      return () => {
        document.removeEventListener('click', handleClickOutside);
      };
    });
  </script>
  
  <style>
    .taskbar {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 40px;
      background-color: #2c3e50;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 10px;
      color: white;
      box-sizing: border-box;
    }
  
    .taskbar-item {
      margin: 0 10px;
    }
  
    .start-button {
      background-color: #3498db;
      border: none;
      color: white;
      padding: 10px 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 0 10px;
      cursor: pointer;
      border-radius: 5px;
    }
  
    .start-button:hover {
      background-color: #2980b9;
    }
  </style>
  
  <div class="taskbar">
    <button class="start-button" on:click={toggleStartMenu}>Start</button>
    <!-- Add more taskbar items as needed -->
  </div>
  
  <StartMenu visible={isStartMenuVisible} />
  
=======================
File: show_tree.sh
=======================
#!/bin/bash

output_file="directory_structure.txt"

# Function to recursively print directory structure
print_tree() {
    local current_dir="$1"
    local indent="$2"
    local is_last="$3"
    local prefix=""

    if [ "$indent" != "" ]; then
        prefix="$indent"
        if [ "$is_last" = true ]; then
            prefix+="└── "
            indent+="    "
        else
            prefix+="├── "
            indent+="│   "
        fi
    fi

    echo "${prefix}$(basename "$current_dir")" >> "$output_file"

    local items=("$current_dir"/*)
    local total_items=${#items[@]}
    local count=1

    for item in "${items[@]}"; do
        if [ -d "$item" ]; then
            print_tree "$item" "$indent" $(( count == total_items ))
        else
            if [ $count -eq $total_items ]; then
                echo "${indent}└── $(basename "$item")" >> "$output_file"
            else
                echo "${indent}├── $(basename "$item")" >> "$output_file"
            fi
        fi
        ((count++))
    done
}

# Clear the output file
echo "" > "$output_file"

# Start printing from the current directory
print_tree "." "" true

echo "Directory structure has been written to $output_file"

=======================
File: window.svelte.ts
=======================
let isDragging = false;
let isResizing = false;
let startX: number, startY: number, initialX: number, initialY: number, initialWidth: number, initialHeight: number;
let tile: HTMLDivElement;
let desktop: HTMLDivElement;
let resizeDirection: string;

export function setTileElement(element: HTMLDivElement) {
  tile = element;
}

export function setDesktopElement(element: HTMLDivElement) {
  desktop = element;
}

export function onMouseDown(event: MouseEvent) {
  const target = event.target as HTMLElement;
  if (target.classList.contains('titlebar')) {
    isDragging = true;
    startX = event.clientX;
    startY = event.clientY;
    initialX = tile.offsetLeft;
    initialY = tile.offsetTop;

    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    event.preventDefault();
  } else if (target.classList.contains('resize-handle')) {
    isResizing = true;
    startX = event.clientX;
    startY = event.clientY;
    initialWidth = tile.clientWidth;
    initialHeight = tile.clientHeight;
    initialX = tile.offsetLeft;
    initialY = tile.offsetTop;
    resizeDirection = target.dataset.direction as string;

    window.addEventListener('mousemove', onResizeMove);
    window.addEventListener('mouseup', onResizeUp);
    event.preventDefault();
  }
}

export function onMouseMove(event: MouseEvent) {
  if (!isDragging) return;

  const dx = event.clientX - startX;
  const dy = event.clientY - startY;

  let newX = initialX + dx;
  let newY = initialY + dy;

  // Boundary conditions
  const rect = desktop.getBoundingClientRect();
  const tileRect = tile.getBoundingClientRect();

  if (newX < 0) newX = 0;
  if (newY < 0) newY = 0;
  if (newX + tileRect.width > rect.width) newX = rect.width - tileRect.width;
  if (newY + tileRect.height > rect.height) newY = rect.height - tileRect.height;

  tile.style.left = `${newX}px`;
  tile.style.top = `${newY}px`;
}

export function onMouseUp() {
  isDragging = false;
  window.removeEventListener('mousemove', onMouseMove);
  window.removeEventListener('mouseup', onMouseUp);
}

export function onResizeMove(event: MouseEvent) {
  if (!isResizing) return;

  const dx = event.clientX - startX;
  const dy = event.clientY - startY;

  let newWidth = initialWidth;
  let newHeight = initialHeight;
  let newX = initialX;
  let newY = initialY;

  if (resizeDirection.includes('right')) {
    newWidth = initialWidth + dx;
  }
  if (resizeDirection.includes('bottom')) {
    newHeight = initialHeight + dy;
  }
  if (resizeDirection.includes('left')) {
    newWidth = initialWidth - dx;
    newX = initialX + dx;
  }
  if (resizeDirection.includes('top')) {
    newHeight = initialHeight - dy;
    newY = initialY + dy;
  }

  // Apply min and max width and height
  const minWidth = 100;
  const minHeight = 100;
  const maxWidth = 500;
  const maxHeight = 500;

  if (newWidth < minWidth) {
    newWidth = minWidth;
    if (resizeDirection.includes('left')) {
      newX = initialX + (initialWidth - minWidth);
    }
  } else if (newWidth > maxWidth) {
    newWidth = maxWidth;
    if (resizeDirection.includes('left')) {
      newX = initialX + (initialWidth - maxWidth);
    }
  }

  if (newHeight < minHeight) {
    newHeight = minHeight;
    if (resizeDirection.includes('top')) {
      newY = initialY + (initialHeight - minHeight);
    }
  } else if (newHeight > maxHeight) {
    newHeight = maxHeight;
    if (resizeDirection.includes('top')) {
      newY = initialY + (initialHeight - maxHeight);
    }
  }

  tile.style.width = `${newWidth}px`;
  tile.style.height = `${newHeight}px`;
  tile.style.left = `${newX}px`;
  tile.style.top = `${newY}px`;
}

export function onResizeUp() {
  isResizing = false;
  window.removeEventListener('mousemove', onResizeMove);
  window.removeEventListener('mouseup', onResizeUp);
}

export const handleMouseLeave = () => {
  onResizeUp();
};

