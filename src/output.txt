=======================
File: app.d.ts
=======================
// See https://kit.svelte.dev/docs/types#app
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};

=======================
File: app.html
=======================
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>

=======================
File: complete_output.sh
=======================
#!/bin/bash



# Run script1.sh and script2.sh
./show_tree.sh 
./repo_to_txt.sh

# Optional: Clean up individual output files if not needed
rm "./directory_structure.txt"
=======================
File: directory_structure.txt
=======================

.
├── app.d.ts
├── app.html
├── complete_output.sh
├── directory_structure.txt
lib
images
├── github.svg
├── svelte-logo.svg
├── svelte-welcome.png
└── svelte-welcome.webp
├── output.txt
├── repo_to_txt.sh
routes
├── +layout.svelte
├── +page.svelte
├── +page.ts
├── ResizeHandle.svelte
├── StartMenu.svelte
├── styles.css
├── Taskbar.svelte
└── Tile.svelte
├── show_tree.sh
├── Tile.ts
└── TileManager.ts

=======================
File: output.txt
=======================

=======================
File: repo_to_txt.sh
=======================
#!/bin/bash

# Directory containing the files
DIR="."

# Output file
OUTPUT="output.txt"

# Clear the output file if it exists
> "$OUTPUT"

# Find all files in the directory and subdirectories, excluding certain file types
find "$DIR" -type f ! \( -name '*.svg' -o -name '*.png' -o -name '*.jpg' -o -name '*.jpeg' -o -name '*.webp' -o -name '*.gif' -o -name '*.bmp' \) | while read -r FILE; do
    FILENAME=$(basename "$FILE")
    # Add a banner with the filename
    echo "=======================" >> "$OUTPUT"
    echo "File: $FILENAME" >> "$OUTPUT"
    echo "=======================" >> "$OUTPUT"
    # Append the contents of each file to the output file
    cat "$FILE" >> "$OUTPUT"
    echo >> "$OUTPUT"  # Add a newline for separation
done

echo "All files have been concatenated into $OUTPUT"

=======================
File: +layout.svelte
=======================
<script>
</script>

<div >


	<main>
		<slot />
	</main>


</div>


=======================
File: +page.svelte
=======================
<script lang="ts">
	import { onMount } from 'svelte';
	import Taskbar from './Taskbar.svelte';
	import Tile from './Tile.svelte';

	let desktop: HTMLDivElement;
	let tiles: Array<{ id: number, x: number, y: number, title: string, isFocused: boolean }> = [];
	let nextTileId = 0;

	onMount(() => {
		// No initial tiles
	});

	function addTile(title: string) {
		const desktopRect = desktop.getBoundingClientRect();
		const tileWidth = 300;
		const tileHeight = 200;

		// Calculate random position
		const maxX = desktopRect.width - tileWidth;
		const maxY = desktopRect.height - tileHeight - 28; // Subtract taskbar height
		const x = Math.floor(Math.random() * maxX);
		const y = Math.floor(Math.random() * maxY);

		const newTile = { id: nextTileId++, x, y, title, isFocused: true };
		tiles = tiles.map(tile => ({ ...tile, isFocused: false }));
		tiles = [...tiles, newTile];
	}

	function handleStartMenuItemClick(item: string) {
		addTile(item);
	}

	function focusTile(id: number) {
		tiles = tiles.map(tile => ({
			...tile,
			isFocused: tile.id === id
		}));
	}
</script>

<div class="desktop" bind:this={desktop}>
	{#each tiles as tile (tile.id)}
		<Tile 
			{desktop} 
			id={tile.id} 
			x={tile.x} 
			y={tile.y} 
			title={tile.title}
			isFocused={tile.isFocused}
			on:focus={(event) => focusTile(event.detail)}
		/>
	{/each}
	<Taskbar 
		on:menuItemClick={({ detail }) => handleStartMenuItemClick(detail)}
		on:focusWindow={(event) => focusTile(event.detail)}
		openWindows={tiles}
	/>
</div>

<style>
	.desktop {
		width: 100%;
		height: 100vh;
		background-color: #008080;
		position: relative;
		overflow: hidden;
	}
</style>
=======================
File: +page.ts
=======================
// since there's no dynamic data here, we can prerender
// it so that it gets served as a static asset in production
export const prerender = true;

=======================
File: ResizeHandle.svelte
=======================
<script lang="ts">
  export let direction: string;
</script>

<style>
  .resize-handle {
    position: absolute;
    background: transparent;
  }

  .resize-handle:hover {
    background: #95a5a6;
  }

  .resize-handle[data-direction*='top'] {
    top: -5px;
    height: 10px;
  }

  .resize-handle[data-direction*='bottom'] {
    bottom: -5px;
    height: 10px;
  }

  .resize-handle[data-direction*='left'] {
    left: -5px;
    width: 10px;
  }

  .resize-handle[data-direction*='right'] {
    right: -5px;
    width: 10px;
  }

  .resize-handle[data-direction='top-left'] {
    cursor: nwse-resize;
    width: 10px;
    height: 10px;
  }

  .resize-handle[data-direction='top-right'] {
    cursor: nesw-resize;
    width: 10px;
    height: 10px;
  }

  .resize-handle[data-direction='bottom-left'] {
    cursor: nesw-resize;
    width: 10px;
    height: 10px;
  }

  .resize-handle[data-direction='bottom-right'] {
    cursor: nwse-resize;
    width: 10px;
    height: 10px;
  }

  .resize-handle[data-direction='top'] {
    cursor: ns-resize;
    width: 100%;
  }

  .resize-handle[data-direction='bottom'] {
    cursor: ns-resize;
    width: 100%;
  }

  .resize-handle[data-direction='left'] {
    cursor: ew-resize;
    height: 100%;
  }

  .resize-handle[data-direction='right'] {
    cursor: ew-resize;
    height: 100%;
  }
</style>

<div
  class="resize-handle"
  data-direction={direction}
  on:mousedown
></div>

=======================
File: StartMenu.svelte
=======================
<script lang="ts">
  import { createEventDispatcher } from 'svelte';

  export let visible: boolean = false;

  const dispatch = createEventDispatcher();

  const menuItems = [
    "Programs",
    "Documents",
    "Settings",
    "Find",
    "Help",
    "Run...",
    "Log Off...",
    "Shut Down..."
  ];

  function handleItemClick(item: string) {
    dispatch('menuItemClick', item);
  }
</script>

<style>
  .start-menu {
    position: absolute;
    bottom: 28px;
    left: 2px;
    width: 200px;
    background-color: #D4D0C8;
    border: 2px solid #808080;
    border-bottom: none;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
    display: none;
    z-index: 10001;
  }

  .start-menu.visible {
    display: block;
  }

  .menu-item {
    padding: 4px 8px;
    cursor: pointer;
    font-family: 'Tahoma', sans-serif;
    font-size: 11px;
  }

  .menu-item:hover {
    background-color: #000080;
    color: white;
  }
</style>

<div class="start-menu {visible ? 'visible' : ''}">
  {#each menuItems as item}
    <div class="menu-item" on:click={() => handleItemClick(item)}>{item}</div>
  {/each}
</div>
=======================
File: styles.css
=======================

=======================
File: Taskbar.svelte
=======================
<script lang="ts">
  import { onMount, createEventDispatcher } from 'svelte';
  import StartMenu from './StartMenu.svelte';

  const dispatch = createEventDispatcher();

  export let openWindows: Array<{ id: number, title: string, isFocused: boolean }> = [];

  let isStartMenuVisible: boolean = false;

  function toggleStartMenu(): void {
    isStartMenuVisible = !isStartMenuVisible;
  }

  function handleClickOutside(event: MouseEvent): void {
    const startMenu = document.querySelector('.start-menu') as HTMLElement;
    const startButton = document.querySelector('.start-button') as HTMLElement;

    if (startMenu && startButton && !startButton.contains(event.target as Node)) {
      isStartMenuVisible = false;
    }
  }

  function handleMenuItemClick(item: string) {
    dispatch('menuItemClick', item);
    isStartMenuVisible = false;
  }

  function focusWindow(id: number) {
    dispatch('focusWindow', id);
  }

  onMount((): () => void => {
    document.addEventListener('click', handleClickOutside);
    return () => {
      document.removeEventListener('click', handleClickOutside);
    };
  });
</script>

<style>
  .taskbar {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 28px;
    background-color: #D4D0C8;
    display: flex;
    align-items: center;
    padding: 0 2px;
    border-top: 2px solid #ffffff;
    box-sizing: border-box;
    z-index: 10000;
  }

  .start-button {
    background: linear-gradient(to bottom, #1fdf25, #0a9710);
    border: 2px solid #ffffff;
    border-right-color: #808080;
    border-bottom-color: #808080;
    color: white;
    font-weight: bold;
    font-size: 11px;
    padding: 2px 5px;
    cursor: pointer;
    display: flex;
    align-items: center;
    height: 22px;
    margin-right: 4px;
  }

  .start-button:before {
    content: '';
    display: inline-block;
    width: 16px;
    height: 16px;
    background-color: #008080;
    margin-right: 4px;
  }

  .start-button:active {
    border: 2px solid #808080;
    border-right-color: #ffffff;
    border-bottom-color: #ffffff;
  }

  .window-tabs {
    display: flex;
    flex-grow: 1;
    overflow-x: auto;
    height: 100%;
  }

  .window-tab {
    background-color: #D4D0C8;
    border: 1px solid #808080;
    border-bottom: none;
    padding: 2px 8px;
    margin-right: 2px;
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 150px;
    height: 22px;
    display: flex;
    align-items: center;
    font-family: 'Tahoma', sans-serif;
    font-size: 11px;
  }

  .window-tab.focused {
    background-color: #ffffff;
    border-top: 2px solid #ffffff;
    border-left: 2px solid #ffffff;
    border-right: 2px solid #808080;
  }
</style>

<div class="taskbar">
  <button class="start-button" on:click={toggleStartMenu}>Start</button>
  <div class="window-tabs">
    {#each openWindows as window (window.id)}
      <div 
        class="window-tab" 
        class:focused={window.isFocused}
        on:click={() => focusWindow(window.id)}
      >
        {window.title}
      </div>
    {/each}
  </div>
</div>

<StartMenu visible={isStartMenuVisible} on:menuItemClick={(event) => handleMenuItemClick(event.detail)} />
=======================
File: Tile.svelte
=======================
<script lang="ts">
	import { onMount, createEventDispatcher } from 'svelte';
	import ResizeHandle from './ResizeHandle.svelte';
	import { Tile as TileClass } from './../Tile';

	export let desktop: HTMLDivElement;
	export let id: number;
	export let x: number = 0;
	export let y: number = 0;
	export let title: string;
	export let isFocused: boolean = false;

	const dispatch = createEventDispatcher();

	let tile: HTMLDivElement;
	let tileInstance: TileClass;

	const directions = [
		'top-left',
		'top-right',
		'bottom-left',
		'bottom-right',
		'top',
		'bottom',
		'left',
		'right'
	];

	onMount(() => {
		tileInstance = new TileClass(tile, desktop);
		tile.style.left = `${x}px`;
		tile.style.top = `${y}px`;
	});

	function focus() {
		dispatch('focus', id);
	}
</script>

<div class="tile" class:focused={isFocused} bind:this={tile} on:mousedown={focus}>
	<div class="titlebar" class:focused={isFocused}>
		<div class="title">{title}</div>
		<div class="buttons">
			<button class="minimize">_</button>
			<button class="maximize">□</button>
			<button class="close">X</button>
		</div>
	</div>
	<div class="body">Window Content for {title}</div>
	{#each directions as direction}
		<ResizeHandle {direction} />
	{/each}
</div>

<style>
	.tile {
		width: 300px;
		height: 200px;
		background-color: #D4D0C8;
		position: absolute;
		top: 0;
		left: 0;
		display: flex;
		flex-direction: column;
		min-width: 100px;
		min-height: 100px;
		max-width: 500px;
		max-height: 500px;
		user-select: none;
		border: 2px solid #ffffff;
		border-right-color: #808080;
		border-bottom-color: #808080;
		box-shadow: 1px 1px 0 #000000;
	}

	.titlebar {
		height: 18px;
		background: linear-gradient(to right, #7b7b7b, #a8a8a8);
		color: #d8d8d8;
		font-weight: bold;
		font-size: 12px;
		display: flex;
		align-items: center;
		justify-content: space-between;
		padding: 2px 3px;
	}

	.titlebar.focused {
		background: linear-gradient(to right, #000080, #1084d0);
		color: white;
	}

	.titlebar:active {
		cursor: grabbing;
	}

	.buttons {
		display: flex;
	}

	.buttons button {
		width: 16px;
		height: 14px;
		margin-left: 2px;
		border: 1px solid #ffffff;
		background-color: #D4D0C8;
		color: #000000;
		font-size: 9px;
		display: flex;
		align-items: center;
		justify-content: center;
		cursor: pointer;
	}

	.body {
		width: 100%;
		height: calc(100% - 22px);
		background-color: #ffffff;
		flex: 1;
		border: 1px solid #808080;
		border-top-color: #ffffff;
		padding: 2px;
		font-family: 'Tahoma', sans-serif;
		font-size: 11px;
	}

	.focused {
		z-index: 100;
	}
</style>
=======================
File: show_tree.sh
=======================
#!/bin/bash

output_file="directory_structure.txt"

# Function to recursively print directory structure
print_tree() {
    local current_dir="$1"
    local indent="$2"
    local is_last="$3"
    local prefix=""

    if [ "$indent" != "" ]; then
        prefix="$indent"
        if [ "$is_last" = true ]; then
            prefix+="└── "
            indent+="    "
        else
            prefix+="├── "
            indent+="│   "
        fi
    fi

    echo "${prefix}$(basename "$current_dir")" >> "$output_file"

    local items=("$current_dir"/*)
    local total_items=${#items[@]}
    local count=1

    for item in "${items[@]}"; do
        if [ -d "$item" ]; then
            print_tree "$item" "$indent" $(( count == total_items ))
        else
            if [ $count -eq $total_items ]; then
                echo "${indent}└── $(basename "$item")" >> "$output_file"
            else
                echo "${indent}├── $(basename "$item")" >> "$output_file"
            fi
        fi
        ((count++))
    done
}

# Clear the output file
echo "" > "$output_file"

# Start printing from the current directory
print_tree "." "" true

echo "Directory structure has been written to $output_file"

=======================
File: Tile.ts
=======================
import { tileManager } from './TileManager';

export class Tile {
    private tile: HTMLDivElement;
    private desktop: HTMLDivElement;
    private isDragging: boolean = false;
    private isResizing: boolean = false;
    private startX!: number;
    private startY!: number;
    private initialX!: number;
    private initialY!: number;
    private initialWidth!: number;
    private initialHeight!: number;
    private resizeDirection!: string;

    constructor(tile: HTMLDivElement, desktop: HTMLDivElement) {
        this.tile = tile;
        this.desktop = desktop;
        tileManager.registerTile(this.tile);
        this.initializeEventListeners();
    }

    private initializeEventListeners() {
        this.tile.addEventListener('mousedown', this.onMouseDown.bind(this));
    }

    private onMouseDown(event: MouseEvent) {
        tileManager.bringToFront(this.tile);
        const target = event.target as HTMLElement;
        if (target.classList.contains('titlebar')) {
            this.isDragging = true;
            this.startX = event.clientX;
            this.startY = event.clientY;
            this.initialX = this.tile.offsetLeft;
            this.initialY = this.tile.offsetTop;

            window.addEventListener('mousemove', this.onMouseMove.bind(this));
            window.addEventListener('mouseup', this.onMouseUp.bind(this));
            event.preventDefault();
        } else if (target.classList.contains('resize-handle')) {
            this.isResizing = true;
            this.startX = event.clientX;
            this.startY = event.clientY;
            this.initialWidth = this.tile.clientWidth;
            this.initialHeight = this.tile.clientHeight;
            this.initialX = this.tile.offsetLeft;
            this.initialY = this.tile.offsetTop;
            this.resizeDirection = target.dataset.direction as string;

            window.addEventListener('mousemove', this.onMouseMove.bind(this));
            window.addEventListener('mouseup', this.onMouseUp.bind(this));
            event.preventDefault();
        }
    }

    private onMouseMove(event: MouseEvent) {
        if (this.isDragging) {
            this.handleDragging(event);
        } else if (this.isResizing) {
            this.handleResizing(event);
        }
    }

    private handleDragging(event: MouseEvent) {
        const dx = event.clientX - this.startX;
        const dy = event.clientY - this.startY;

        let newX = this.initialX + dx;
        let newY = this.initialY + dy;

        const desktopRect = this.desktop.getBoundingClientRect();
        const tileRect = this.tile.getBoundingClientRect();

        newX = Math.max(0, Math.min(newX, desktopRect.width - tileRect.width));
        newY = Math.max(0, Math.min(newY, desktopRect.height - tileRect.height));

        this.tile.style.left = `${newX}px`;
        this.tile.style.top = `${newY}px`;
    }

    private handleResizing(event: MouseEvent) {
        const dx = event.clientX - this.startX;
        const dy = event.clientY - this.startY;

        const desktopRect = this.desktop.getBoundingClientRect();
        const minWidth = 100;
        const minHeight = 100;
        const maxWidth = 500;
        const maxHeight = 500;

        let newWidth = this.initialWidth;
        let newHeight = this.initialHeight;
        let newX = this.initialX;
        let newY = this.initialY;

        if (this.resizeDirection.includes('right')) {
            newWidth = Math.min(
                Math.max(minWidth, this.initialWidth + dx),
                desktopRect.width - this.initialX,
                maxWidth
            );
        }
        if (this.resizeDirection.includes('bottom')) {
            newHeight = Math.min(
                Math.max(minHeight, this.initialHeight + dy),
                desktopRect.height - this.initialY,
                maxHeight
            );
        }
        if (this.resizeDirection.includes('left')) {
            const maxLeftResize = this.initialX + this.initialWidth - minWidth;
            const leftResize = Math.min(dx, maxLeftResize);
            newWidth = Math.min(
                Math.max(minWidth, this.initialWidth - leftResize),
                maxWidth,
                this.initialX + this.initialWidth
            );
            newX = Math.max(0, Math.min(this.initialX + dx, this.initialX + this.initialWidth - minWidth));
        }
        if (this.resizeDirection.includes('top')) {
            const maxTopResize = this.initialY + this.initialHeight - minHeight;
            const topResize = Math.min(dy, maxTopResize);
            newHeight = Math.min(
                Math.max(minHeight, this.initialHeight - topResize),
                maxHeight,
                this.initialY + this.initialHeight
            );
            newY = Math.max(0, Math.min(this.initialY + dy, this.initialY + this.initialHeight - minHeight));
        }

        this.tile.style.width = `${newWidth}px`;
        this.tile.style.height = `${newHeight}px`;
        this.tile.style.left = `${newX}px`;
        this.tile.style.top = `${newY}px`;
    }

    private onMouseUp() {
        this.isDragging = false;
        this.isResizing = false;
        window.removeEventListener('mousemove', this.onMouseMove.bind(this));
        window.removeEventListener('mouseup', this.onMouseUp.bind(this));
    }
}
=======================
File: TileManager.ts
=======================
class TileManager {
    private static instance: TileManager;
    private tiles: HTMLDivElement[] = [];
  
    private constructor() {}
  
    public static getInstance(): TileManager {
      if (!TileManager.instance) {
        TileManager.instance = new TileManager();
      }
      return TileManager.instance;
    }
  
    public registerTile(tile: HTMLDivElement) {
      this.tiles.push(tile);
      this.reindexTiles();
    }
  
    public bringToFront(tile: HTMLDivElement) {
      this.tiles = this.tiles.filter(t => t !== tile);
      this.tiles.push(tile);
      this.reindexTiles();
    }
  
    private reindexTiles() {
      this.tiles.forEach((tile, index) => {
        tile.style.zIndex = String(index + 1);
      });
    }
  }
  
  export const tileManager = TileManager.getInstance();
  
