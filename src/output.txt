=======================
File: app.d.ts
=======================
// See https://kit.svelte.dev/docs/types#app
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};

=======================
File: app.html
=======================
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>

=======================
File: complete_output.sh
=======================
#!/bin/bash



# Run script1.sh and script2.sh
./show_tree.sh 
./repo_to_txt.sh

# Optional: Clean up individual output files if not needed
rm "./directory_structure.txt"
=======================
File: directory_structure.txt
=======================

.
├── app.d.ts
├── app.html
├── complete_output.sh
├── directory_structure.txt
lib
classes
├── Tile.ts
└── TileManager.ts
components
Taskbar
├── StartButton.svelte
├── StartMenu.svelte
├── Taskbar.svelte
└── TaskbarButton.svelte
Window
├── backgroundColorStore.ts
├── Calculator.svelte
├── Notepad.svelte
├── ResizeHandle.svelte
├── Settings.svelte
├── Tile.svelte
├── Titlebar.svelte
├── WindowButtons.svelte
└── WindowContent.svelte
styles
└── desktop.css
types
└── TileData.ts
utils
├── addTile.ts
├── focusTile.ts
├── focusTopmostTile.ts
├── minimizeTile.ts
└── restoreTile.ts
├── output.txt
├── repo_to_txt.sh
routes
├── +layout.svelte
├── +page.svelte
├── +page.ts
└── styles.css
└── show_tree.sh

=======================
File: lib/classes/Tile.ts
=======================
import { tileManager } from './TileManager.ts';

export class Tile {
    private tile: HTMLDivElement;
    private desktop: HTMLDivElement;
    private isDragging: boolean = false;
    private isResizing: boolean = false;
    private startX!: number;
    private startY!: number;
    private initialX!: number;
    private initialY!: number;
    private initialWidth!: number;
    private initialHeight!: number;
    private resizeDirection!: string;
    private onFocus: () => void;

    constructor(tile: HTMLDivElement, desktop: HTMLDivElement, onFocus: () => void) {
        this.tile = tile;
        this.desktop = desktop;
        this.onFocus = onFocus;
        tileManager.registerTile(this.tile);
        this.initializeEventListeners();
    }

    private initializeEventListeners() {
        this.tile.addEventListener('mousedown', this.onMouseDown.bind(this));
    }

    public startDragging(event: MouseEvent) {
        this.isDragging = true;
        this.startX = event.clientX;
        this.startY = event.clientY;
        this.initialX = this.tile.offsetLeft;
        this.initialY = this.tile.offsetTop;

        window.addEventListener('mousemove', this.onMouseMove.bind(this));
        window.addEventListener('mouseup', this.onMouseUp.bind(this));
        event.preventDefault();
    }

    public focus() {
        tileManager.bringToFront(this.tile);
        this.onFocus();
    }

    private onMouseDown(event: MouseEvent) {
        this.focus();
        const target = event.target as HTMLElement;
        if (target.classList.contains('resize-handle')) {
            this.isResizing = true;
            this.startX = event.clientX;
            this.startY = event.clientY;
            this.initialWidth = this.tile.clientWidth;
            this.initialHeight = this.tile.clientHeight;
            this.initialX = this.tile.offsetLeft;
            this.initialY = this.tile.offsetTop;
            this.resizeDirection = target.dataset.direction as string;

            window.addEventListener('mousemove', this.onMouseMove.bind(this));
            window.addEventListener('mouseup', this.onMouseUp.bind(this));
            event.preventDefault();
        }
    }

    private onMouseMove(event: MouseEvent) {
        if (this.isDragging) {
            this.handleDragging(event);
        } else if (this.isResizing) {
            this.handleResizing(event);
        }
    }

    private handleDragging(event: MouseEvent) {
        const dx = event.clientX - this.startX;
        const dy = event.clientY - this.startY;

        let newX = this.initialX + dx;
        let newY = this.initialY + dy;

        const desktopRect = this.desktop.getBoundingClientRect();
        const tileRect = this.tile.getBoundingClientRect();

        newX = Math.max(0, Math.min(newX, desktopRect.width - tileRect.width));
        newY = Math.max(0, Math.min(newY, desktopRect.height - tileRect.height));

        this.tile.style.left = `${newX}px`;
        this.tile.style.top = `${newY}px`;
    }

    private handleResizing(event: MouseEvent) {
        const dx = event.clientX - this.startX;
        const dy = event.clientY - this.startY;
    
        const desktopRect = this.desktop.getBoundingClientRect();
        const minWidth = 100;
        const minHeight = 100;
        const maxWidth = 500;
        const maxHeight = 500;
    
        let newWidth = this.initialWidth;
        let newHeight = this.initialHeight;
        let newX = this.initialX;
        let newY = this.initialY;
    
        if (this.resizeDirection.includes('right')) {
            newWidth = Math.min(
                Math.max(minWidth, this.initialWidth + dx),
                desktopRect.width - this.initialX,
                maxWidth
            );
        }
        if (this.resizeDirection.includes('bottom')) {
            newHeight = Math.min(
                Math.max(minHeight, this.initialHeight + dy),
                desktopRect.height - this.initialY,
                maxHeight
            );
        }
        if (this.resizeDirection.includes('left')) {
            const maxLeftMove = Math.min(this.initialWidth - minWidth, this.initialX);
            const leftMove = Math.max(-maxLeftMove, Math.min(dx, this.initialWidth - minWidth));
            newWidth = Math.min(this.initialWidth - leftMove, maxWidth);
            newX = this.initialX + this.initialWidth - newWidth;
        }
        if (this.resizeDirection.includes('top')) {
            const maxTopMove = Math.min(this.initialHeight - minHeight, this.initialY);
            const topMove = Math.max(-maxTopMove, Math.min(dy, this.initialHeight - minHeight));
            newHeight = Math.min(this.initialHeight - topMove, maxHeight);
            newY = this.initialY + this.initialHeight - newHeight;
        }
    
        this.tile.style.width = `${newWidth}px`;
        this.tile.style.height = `${newHeight}px`;
        this.tile.style.left = `${newX}px`;
        this.tile.style.top = `${newY}px`;
    }

    private onMouseUp() {
        this.isDragging = false;
        this.isResizing = false;
        window.removeEventListener('mousemove', this.onMouseMove.bind(this));
        window.removeEventListener('mouseup', this.onMouseUp.bind(this));
    }
}
=======================
File: lib/classes/TileManager.ts
=======================
class TileManager {
    private static instance: TileManager;
    private tiles: HTMLDivElement[] = [];
  
    private constructor() {}
  
    public static getInstance(): TileManager {
      if (!TileManager.instance) {
        TileManager.instance = new TileManager();
      }
      return TileManager.instance;
    }
  
    public registerTile(tile: HTMLDivElement) {
      this.tiles.push(tile);
      this.reindexTiles();
    }
  
    public bringToFront(tile: HTMLDivElement) {
      this.tiles = this.tiles.filter(t => t !== tile);
      this.tiles.push(tile);
      this.reindexTiles();
    }
  
    private reindexTiles() {
      this.tiles.forEach((tile, index) => {
        tile.style.zIndex = String(index + 1);
      });
    }
  }
  
  export const tileManager = TileManager.getInstance();
  
=======================
File: lib/components/Taskbar/StartButton.svelte
=======================

<script lang="ts">
  import { createEventDispatcher } from 'svelte';

  const dispatch = createEventDispatcher();

  function handleClick() {
    dispatch('click');
  }
</script>

<button class="start-button" on:click={handleClick}>Start</button>

<style>
  .start-button {
    background: linear-gradient(to bottom, #1fdf25, #0a9710);
    border: 2px solid #ffffff;
    border-right-color: #808080;
    border-bottom-color: #808080;
    color: white;
    font-weight: bold;
    font-size: 11px;
    padding: 2px 5px;
    cursor: pointer;
    display: flex;
    align-items: center;
    height: 22px;
    margin-right: 4px;
  }

  .start-button:before {
    content: '';
    display: inline-block;
    width: 16px;
    height: 16px;
    background-color: #008080;
    margin-right: 4px;
  }

  .start-button:active {
    border: 2px solid #808080;
    border-right-color: #ffffff;
    border-bottom-color: #ffffff;
  }
</style>
=======================
File: lib/components/Taskbar/StartMenu.svelte
=======================
<script lang="ts">
  import { createEventDispatcher } from 'svelte';

  export let visible: boolean = false;
  
  const dispatch = createEventDispatcher();

  export let items = [
    "Programs",
    "Documents",
    "Settings",
    "Find",
    "Help",
    "Run...",
    "Log Off...",
    "Shut Down..."
  ];

  function handleItemClick(item: string) {
    dispatch('menuItemClick', item);
  }
</script>

<style>
  .start-menu {
    position: absolute;
    bottom: 28px;
    left: 2px;
    width: 200px;
    background-color: #D4D0C8;
    border: 2px solid #808080;
    border-bottom: none;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
    display: none;
    z-index: 10001;
  }

  .start-menu.visible {
    display: block;
  }

  .menu-item {
    padding: 4px 8px;
    cursor: pointer;
    font-family: 'Tahoma', sans-serif;
    font-size: 11px;
  }

  .menu-item:hover {
    background-color: #000080;
    color: white;
  }
</style>

<div class="start-menu {visible ? 'visible' : ''}">
  {#each items as item}
    <div class="menu-item" on:click={() => handleItemClick(item)}>{item}</div>
  {/each}
</div>
=======================
File: lib/components/Taskbar/Taskbar.svelte
=======================
<script lang="ts">
  import { onMount, createEventDispatcher } from 'svelte';
  import StartButton from './StartButton.svelte';
  import StartMenu from './StartMenu.svelte';
  import TaskbarButton from './TaskbarButton.svelte';
  import type { TileData } from '$lib/types/TileData';

  const dispatch = createEventDispatcher();

  export let tiles: TileData[] = [];
  export let startMenuItems: string[] = [];

  let isStartMenuVisible: boolean = false;

  function toggleStartMenu(): void {
    isStartMenuVisible = !isStartMenuVisible;
  }

  function handleClickOutside(event: MouseEvent): void {
    const startMenu = document.querySelector('.start-menu') as HTMLElement;
    const startButton = document.querySelector('.start-button') as HTMLElement;

    if (startMenu && startButton && !startButton.contains(event.target as Node)) {
      isStartMenuVisible = false;
    }
  }

  function handleMenuItemClick(item: string) {
    dispatch('menuItemClick', item);
    isStartMenuVisible = false;
  }

  function handleWindowClick(id: number, isMinimized: boolean) {
    dispatch(isMinimized ? 'restoreWindow' : 'focusWindow', id);
  }

  onMount(() => {
    document.addEventListener('click', handleClickOutside);
    return () => document.removeEventListener('click', handleClickOutside);
  });
</script>

<div class="taskbar">
  <StartButton on:click={toggleStartMenu} />
  <div class="window-tabs">
    {#each tiles as tile (tile.id)}
      <TaskbarButton
        title={tile.title}
        isFocused={tile.isFocused}
        isMinimized={tile.isMinimized}
        on:click={() => handleWindowClick(tile.id, tile.isMinimized)}
      />
    {/each}
  </div>
</div>

<StartMenu
  visible={isStartMenuVisible}
  items={startMenuItems}
  on:menuItemClick={(event) => handleMenuItemClick(event.detail)}
/>

<style>
  .taskbar {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 28px;
    background-color: #d4d0c8;
    display: flex;
    align-items: center;
    padding: 0 2px;
    border-top: 2px solid #ffffff;
    box-sizing: border-box;
    z-index: 10000;
  }

  .window-tabs {
    display: flex;
    flex-grow: 1;
    overflow-x: auto;
    height: 100%;
  }
</style>
=======================
File: lib/components/Taskbar/TaskbarButton.svelte
=======================

<script lang="ts">
  export let title: string;
  export let isFocused: boolean;
  export let isMinimized: boolean;
</script>

<div
  class="window-tab"
  class:focused={isFocused}
  class:minimized={isMinimized}
  on:click
>
  {title}
</div>

<style>
  .window-tab {
    background-color: #d4d0c8;
    border: 1px solid #808080;
    border-bottom: none;
    padding: 2px 8px;
    margin-right: 2px;
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 150px;
    height: 22px;
    display: flex;
    align-items: center;
    font-family: 'Tahoma', sans-serif;
    font-size: 11px;
  }

  .window-tab.focused {
    background-color: #ffffff;
    border-top: 2px solid #ffffff;
    border-left: 2px solid #ffffff;
    border-right: 2px solid #808080;
  }

  .window-tab.minimized {
    background-color: #a0a0a0;
  }
</style>
=======================
File: lib/components/Window/backgroundColorStore.ts
=======================
import { writable } from 'svelte/store';

export const backgroundColor = writable('#008080');
=======================
File: lib/components/Window/Calculator.svelte
=======================
<script lang="ts">
    let display = '0';
    let currentOperation = '';
    let previousValue = 0;
  
    function handleButtonClick(value: string) {
      if (value === 'C') {
        display = '0';
        currentOperation = '';
        previousValue = 0;
      } else if (value === '=') {
        calculate();
      } else if (['+', '-', '*', '/'].includes(value)) {
        currentOperation = value;
        previousValue = parseFloat(display);
        display = '0';
      } else {
        display = display === '0' ? value : display + value;
      }
    }
  
    function calculate() {
      const currentValue = parseFloat(display);
      let result = 0;
      switch (currentOperation) {
        case '+':
          result = previousValue + currentValue;
          break;
        case '-':
          result = previousValue - currentValue;
          break;
        case '*':
          result = previousValue * currentValue;
          break;
        case '/':
          result = previousValue / currentValue;
          break;
      }
      display = result.toString();
      currentOperation = '';
    }
  </script>
  
  <div class="calculator">
    <div class="display">{display}</div>
    <div class="buttons">
      {#each ['7', '8', '9', '/', '4', '5', '6', '*', '1', '2', '3', '-', '0', 'C', '=', '+'] as button}
        <button on:click={() => handleButtonClick(button)}>{button}</button>
      {/each}
    </div>
  </div>
  
  <style>
    .calculator {
      width: 200px;
      margin: 10px auto;
      background-color: #d4d0c8;
      border: 2px solid #808080;
      border-top-color: #ffffff;
      border-left-color: #ffffff;
    }
    .display {
      background-color: #ffffff;
      border: 1px solid #808080;
      margin: 5px;
      padding: 5px;
      text-align: right;
      font-family: 'Courier New', monospace;
    }
    .buttons {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2px;
      padding: 5px;
    }
    button {
      background-color: #d4d0c8;
      border: 2px solid #808080;
      border-top-color: #ffffff;
      border-left-color: #ffffff;
      padding: 5px;
      font-family: 'Tahoma', sans-serif;
      font-size: 12px;
    }
    button:active {
      border: 2px solid #808080;
      border-bottom-color: #ffffff;
      border-right-color: #ffffff;
    }
  </style>
=======================
File: lib/components/Window/Notepad.svelte
=======================
<script lang="ts">
    let text = '';
  </script>
  
  <div class="notepad">
    <textarea bind:value={text} placeholder="Type your text here..."></textarea>
  </div>
  
  <style>
    .notepad {
      width: 100%;
      height: 100%;
      padding: 5px;
      box-sizing: border-box;
    }
    textarea {
      width: 100%;
      height: 100%;
      resize: none;
      border: 1px solid #808080;
      background-color: #ffffff;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      padding: 5px;
      box-sizing: border-box;
    }
  </style>
=======================
File: lib/components/Window/ResizeHandle.svelte
=======================
<script lang="ts">
  export let direction: string;
</script>

<style>
  .resize-handle {
    position: absolute;
    background: transparent;
  }

  .resize-handle:hover {
    background: #95a5a6;
  }

  .resize-handle[data-direction*='top'] {
    top: -5px;
    height: 10px;
  }

  .resize-handle[data-direction*='bottom'] {
    bottom: -5px;
    height: 10px;
  }

  .resize-handle[data-direction*='left'] {
    left: -5px;
    width: 10px;
  }

  .resize-handle[data-direction*='right'] {
    right: -5px;
    width: 10px;
  }

  .resize-handle[data-direction='top-left'] {
    cursor: nwse-resize;
    width: 10px;
    height: 10px;
  }

  .resize-handle[data-direction='top-right'] {
    cursor: nesw-resize;
    width: 10px;
    height: 10px;
  }

  .resize-handle[data-direction='bottom-left'] {
    cursor: nesw-resize;
    width: 10px;
    height: 10px;
  }

  .resize-handle[data-direction='bottom-right'] {
    cursor: nwse-resize;
    width: 10px;
    height: 10px;
  }

  .resize-handle[data-direction='top'] {
    cursor: ns-resize;
    width: 100%;
  }

  .resize-handle[data-direction='bottom'] {
    cursor: ns-resize;
    width: 100%;
  }

  .resize-handle[data-direction='left'] {
    cursor: ew-resize;
    height: 100%;
  }

  .resize-handle[data-direction='right'] {
    cursor: ew-resize;
    height: 100%;
  }
</style>

<div
  class="resize-handle"
  data-direction={direction}
  on:mousedown
></div>

=======================
File: lib/components/Window/Settings.svelte
=======================
<script lang="ts">
    import { backgroundColor } from './backgroundColorStore';
    
    let soundEnabled = true;
    let screenSaverTimeout = 15;
  
    function handleApply() {
      // In a real application, you might want to save these settings to some persistent storage
      console.log('Settings applied');
    }
  </script>
  
  <div class="settings">
    <h2>Display Settings</h2>
    <div class="setting">
      <label for="background-color">Background Color:</label>
      <input type="color" id="background-color" bind:value={$backgroundColor}>
    </div>
  
    <h2>Sound Settings</h2>
    <div class="setting">
      <label>
        <input type="checkbox" bind:checked={soundEnabled}>
        Enable System Sounds
      </label>
    </div>
  
    <h2>Screen Saver</h2>
    <div class="setting">
      <label for="screensaver-timeout">Wait</label>
      <input type="number" id="screensaver-timeout" bind:value={screenSaverTimeout} min="1" max="60">
      <span>minutes</span>
    </div>
  
    <button class="apply-button" on:click={handleApply}>Apply</button>
  </div>
  
  <style>
    .settings {
      padding: 10px;
      font-family: 'Tahoma', sans-serif;
      font-size: 11px;
    }
    h2 {
      font-size: 14px;
      margin-top: 15px;
      margin-bottom: 5px;
      border-bottom: 1px solid #808080;
    }
    .setting {
      margin-bottom: 10px;
    }
    label {
      display: inline-block;
      width: 150px;
    }
    input[type="color"] {
      width: 50px;
      height: 20px;
      border: 1px solid #808080;
    }
    input[type="number"] {
      width: 40px;
    }
    .apply-button {
      background-color: #d4d0c8;
      border: 2px solid #808080;
      border-top-color: #ffffff;
      border-left-color: #ffffff;
      padding: 5px 10px;
      font-family: 'Tahoma', sans-serif;
      font-size: 11px;
      margin-top: 10px;
    }
    .apply-button:active {
      border: 2px solid #808080;
      border-bottom-color: #ffffff;
      border-right-color: #ffffff;
    }
  </style>
=======================
File: lib/components/Window/Tile.svelte
=======================

<script lang="ts">
  import { onMount, createEventDispatcher } from 'svelte';
  import ResizeHandle from './ResizeHandle.svelte';
  import Titlebar from './Titlebar.svelte';
  import WindowContent from './WindowContent.svelte';
  import { Tile as TileClass } from '$lib/classes/Tile';
  import type { TileData } from '$lib/types/TileData';

  export let desktop: HTMLDivElement;
  export let id: number;
  export let x: number;
  export let y: number;
  export let title: string;
  export let isFocused: boolean;
  export let isMinimized: boolean = false;
  export let zIndex: number;

  const dispatch = createEventDispatcher();

  let tile: HTMLDivElement;
  let tileInstance: TileClass;

  const directions = [
    'top-left', 'top-right', 'bottom-left', 'bottom-right',
    'top', 'bottom', 'left', 'right'
  ];

  onMount(() => {
    tileInstance = new TileClass(tile, desktop, () => dispatch('focus', id));
    tile.style.left = `${x}px`;
    tile.style.top = `${y}px`;
  });

  function handleMouseDown(event: MouseEvent) {
    const titlebar = tile.querySelector('.titlebar');
    if (titlebar && titlebar.contains(event.target as Node)) {
      tileInstance.startDragging(event);
    }
    tileInstance.focus();
  }

  function handleTitlebarAction(event: CustomEvent) {
    dispatch(event.type, id);
  }

  $: tile && (tile.style.zIndex = zIndex.toString());
</script>

<div class="tile" class:focused={isFocused} class:minimized={isMinimized} bind:this={tile} on:mousedown={handleMouseDown}>
  <Titlebar {title} {isFocused} 
    on:minimize={handleTitlebarAction}
    on:maximize={handleTitlebarAction}
    on:close={handleTitlebarAction}
  />
  <WindowContent {title} />
  {#each directions as direction}
    <ResizeHandle {direction} />
  {/each}
</div>

<style>
  .tile {
    width: 300px;
    height: 200px;
    background-color: #D4D0C8;
    position: absolute;
    top: 0;
    left: 0;
    display: flex;
    flex-direction: column;
    min-width: 100px;
    min-height: 100px;
    max-width: 500px;
    max-height: 500px;
    user-select: none;
    border: 2px solid #ffffff;
    border-right-color: #808080;
    border-bottom-color: #808080;
    box-shadow: 1px 1px 0 #000000;
  }

  .tile.minimized {
    display: none;
  }

  .tile.focused {
    z-index: 100;
  }
</style>
=======================
File: lib/components/Window/Titlebar.svelte
=======================


<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  import WindowButtons from './WindowButtons.svelte';

  export let title: string;
  export let isFocused: boolean;

  const dispatch = createEventDispatcher();

  function handleButtonAction(event: CustomEvent) {
    dispatch(event.type, event.detail);
  }
</script>

<div class="titlebar" class:focused={isFocused}>
  <div class="title">{title}</div>
  <WindowButtons 
    on:minimize={handleButtonAction}
    on:maximize={handleButtonAction}
    on:close={handleButtonAction}
  />
</div>

<style>
  .titlebar {
    height: 18px;
    background: linear-gradient(to right, #7b7b7b, #a8a8a8);
    color: #d8d8d8;
    font-weight: bold;
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 2px 3px;
    cursor: move;
  }

  .titlebar.focused {
    background: linear-gradient(to right, #000080, #1084d0);
    color: white;
  }
</style>
=======================
File: lib/components/Window/WindowButtons.svelte
=======================


<script lang="ts">
  import { createEventDispatcher } from 'svelte';

  const dispatch = createEventDispatcher();

  function handleMinimize() {
    dispatch('minimize');
  }

  function handleMaximize() {
    dispatch('maximize');
  }

  function handleClose() {
    dispatch('close');
  }
</script>

<div class="buttons">
  <button class="minimize" on:click={handleMinimize}>_</button>
  <button class="maximize" on:click={handleMaximize}>□</button>
  <button class="close" on:click={handleClose}>X</button>
</div>

<style>
  .buttons {
    display: flex;
  }

  .buttons button {
    width: 16px;
    height: 14px;
    margin-left: 2px;
    border: 1px solid #ffffff;
    background-color: #D4D0C8;
    color: #000000;
    font-size: 9px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
  }
</style>
=======================
File: lib/components/Window/WindowContent.svelte
=======================
<script lang="ts">
  import Calculator from './Calculator.svelte';
  import Notepad from './Notepad.svelte';
  import Settings from './Settings.svelte';

  export let title: string;
</script>

<div class="body">
  {#if title === 'Calculator'}
    <Calculator />
  {:else if title === 'Notepad'}
    <Notepad />
  {:else if title === 'Settings'}
    <Settings />
  {:else}
    <p>Window Content for {title}</p>
  {/if}
</div>

<style>
  .body {
    width: 100%;
    height: calc(100% - 22px);
    background-color: #ffffff;
    flex: 1;
    border: 1px solid #808080;
    border-top-color: #ffffff;
    padding: 2px;
    font-family: 'Tahoma', sans-serif;
    font-size: 11px;
    overflow: auto;
  }
</style>
=======================
File: lib/styles/desktop.css
=======================
.desktop {
  width: 100%;
  height: 100vh;
  position: relative;
  overflow: hidden;
}
=======================
File: lib/types/TileData.ts
=======================
export interface TileData {
    id: number;
    x: number;
    y: number;
    title: string;
    isFocused: boolean;
    isMinimized: boolean;
    zIndex: number;
}
=======================
File: lib/utils/addTile.ts
=======================
// File: lib/utils/addTile.ts

import type { TileData } from '../types/TileData';

export function addTile(tiles: TileData[], nextTileId: number, desktop: HTMLDivElement, title: string): TileData[] {
    const desktopRect = desktop.getBoundingClientRect();
    const tileWidth = 300;
    const tileHeight = 200;

    const maxX = desktopRect.width - tileWidth;
    const maxY = desktopRect.height - tileHeight - 28;
    const x = Math.floor(Math.random() * maxX);
    const y = Math.floor(Math.random() * maxY);

    const maxZIndex = Math.max(0, ...tiles.map(tile => tile.zIndex));

    const newTile: TileData = { 
        id: nextTileId, 
        x, 
        y, 
        title, 
        isFocused: true, 
        isMinimized: false, 
        zIndex: maxZIndex + 1 
    };
    return [...tiles.map(tile => ({ ...tile, isFocused: false })), newTile];
}
=======================
File: lib/utils/focusTile.ts
=======================
import type { TileData } from '../types/TileData';

export function focusTile(tiles: TileData[], id: number): TileData[] {
    const maxZIndex = Math.max(...tiles.map(tile => tile.zIndex));
    return tiles.map(tile => ({
        ...tile,
        isFocused: tile.id === id && !tile.isMinimized,
        zIndex: tile.id === id ? maxZIndex + 1 : tile.zIndex
    }));
}
=======================
File: lib/utils/focusTopmostTile.ts
=======================
// File: lib/utils/focusTopmostTile.ts

import type { TileData } from '../types/TileData';

export function focusTopmostTile(tiles: TileData[]): TileData[] {
    const visibleTiles = tiles.filter(tile => !tile.isMinimized);
    if (visibleTiles.length === 0) return tiles;
    
    const maxZIndex = Math.max(...visibleTiles.map(tile => tile.zIndex));
    const topmostTileId = visibleTiles.find(tile => tile.zIndex === maxZIndex)!.id;
    
    return tiles.map(tile => ({
        ...tile,
        isFocused: tile.id === topmostTileId,
        zIndex: tile.id === topmostTileId ? maxZIndex + 1 : tile.zIndex
    }));
}
=======================
File: lib/utils/minimizeTile.ts
=======================
// File: lib/utils/minimizeTile.ts

import type { TileData } from '../types/TileData';
import { focusTopmostTile } from './focusTopmostTile';

export function minimizeTile(tiles: TileData[], id: number): TileData[] {
    const updatedTiles = tiles.map(tile => 
        tile.id === id ? { ...tile, isMinimized: true, isFocused: false } : tile
    );
    return focusTopmostTile(updatedTiles);
}
=======================
File: lib/utils/restoreTile.ts
=======================
// File: lib/utils/restoreTile.ts

import type { TileData } from '../types/TileData';

export function restoreTile(tiles: TileData[], id: number): TileData[] {
    const maxZIndex = Math.max(...tiles.map(tile => tile.zIndex));
    return tiles.map(tile => 
        tile.id === id 
            ? { ...tile, isMinimized: false, isFocused: true, zIndex: maxZIndex + 1 } 
            : { ...tile, isFocused: false }
    );
}
=======================
File: output.txt
=======================

=======================
File: repo_to_txt.sh
=======================
#!/bin/bash

# Directory containing the files
DIR="."
# Output file
OUTPUT="output.txt"
# Clear the output file if it exists
> "$OUTPUT"

# Find all files in the directory and subdirectories, excluding certain file types
find "$DIR" -type f ! \( -name '*.svg' -o -name '*.png' -o -name '*.jpg' -o -name '*.jpeg' -o -name '*.webp' -o -name '*.gif' -o -name '*.bmp' \) | while read -r FILE; do
    # Get the filename
    FILENAME=$(basename "$FILE")
    # Get the relative path (remove the leading "./" if present)
    RELPATH=$(dirname "$FILE" | sed 's|^\./||')
    
    # Add a banner with the filename and its path
    echo "=======================" >> "$OUTPUT"
    if [ "$RELPATH" = "." ]; then
        echo "File: $FILENAME" >> "$OUTPUT"
    else
        echo "File: $RELPATH/$FILENAME" >> "$OUTPUT"
    fi
    echo "=======================" >> "$OUTPUT"
    
    # Append the contents of each file to the output file
    cat "$FILE" >> "$OUTPUT"
    echo >> "$OUTPUT"  # Add a newline for separation
done

echo "All files have been concatenated into $OUTPUT"
=======================
File: routes/+layout.svelte
=======================
<script>
</script>

<div >


	<main>
		<slot />
	</main>


</div>


=======================
File: routes/+page.svelte
=======================
<script lang="ts">
  import { onMount } from 'svelte';
  import Taskbar from '$lib/components/Taskbar/Taskbar.svelte';
  import Tile from '$lib/components/Window/Tile.svelte';
  import type { TileData } from '$lib/types/TileData';
  import { addTile } from '$lib/utils/addTile';
  import { focusTile } from '$lib/utils/focusTile';
  import { minimizeTile } from '$lib/utils/minimizeTile';
  import { restoreTile } from '$lib/utils/restoreTile';
  import { focusTopmostTile } from '$lib/utils/focusTopmostTile';
  import { backgroundColor } from '$lib/components/Window/backgroundColorStore';
  import '$lib/styles/desktop.css';

  let desktop: HTMLDivElement;
  let tiles: TileData[] = [];
  let nextTileId = 0;

  onMount(() => {
    // No initial tiles
  });

  function handleStartMenuItemClick(item: string) {
    tiles = addTile(tiles, nextTileId++, desktop, item);
  }

  function handleFocusTile(id: number) {
    tiles = focusTile(tiles, id);
  }

  function handleMinimizeTile(id: number) {
    tiles = minimizeTile(tiles, id);
  }

  function handleRestoreTile(id: number) {
    tiles = restoreTile(tiles, id);
  }

  function handleCloseTile(id: number) {
    tiles = tiles.filter(tile => tile.id !== id);
    tiles = focusTopmostTile(tiles);
  }

  const startMenuItems = ['Calculator', 'Notepad', 'Settings'];
</script>

<div class="desktop" bind:this={desktop} style:background-color={$backgroundColor}>
  {#each tiles as tile (tile.id)}
    <Tile 
      {...tile}
      {desktop}
      on:focus={() => handleFocusTile(tile.id)}
      on:minimize={() => handleMinimizeTile(tile.id)}
      on:close={() => handleCloseTile(tile.id)}
    />
  {/each}
  <Taskbar 
    on:menuItemClick={({ detail }) => handleStartMenuItemClick(detail)}
    on:focusWindow={({ detail }) => handleFocusTile(detail)}
    on:restoreWindow={({ detail }) => handleRestoreTile(detail)}
    {tiles}
    {startMenuItems}
  />
</div>
=======================
File: routes/+page.ts
=======================
// since there's no dynamic data here, we can prerender
// it so that it gets served as a static asset in production
export const prerender = true;

=======================
File: routes/styles.css
=======================

=======================
File: show_tree.sh
=======================
#!/bin/bash

output_file="directory_structure.txt"

# Function to recursively print directory structure
print_tree() {
    local current_dir="$1"
    local indent="$2"
    local is_last="$3"
    local prefix=""

    if [ "$indent" != "" ]; then
        prefix="$indent"
        if [ "$is_last" = true ]; then
            prefix+="└── "
            indent+="    "
        else
            prefix+="├── "
            indent+="│   "
        fi
    fi

    echo "${prefix}$(basename "$current_dir")" >> "$output_file"

    local items=("$current_dir"/*)
    local total_items=${#items[@]}
    local count=1

    for item in "${items[@]}"; do
        if [ -d "$item" ]; then
            print_tree "$item" "$indent" $(( count == total_items ))
        else
            if [ $count -eq $total_items ]; then
                echo "${indent}└── $(basename "$item")" >> "$output_file"
            else
                echo "${indent}├── $(basename "$item")" >> "$output_file"
            fi
        fi
        ((count++))
    done
}

# Clear the output file
echo "" > "$output_file"

# Start printing from the current directory
print_tree "." "" true

echo "Directory structure has been written to $output_file"

