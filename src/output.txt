=======================
File: app.d.ts
=======================
// See https://kit.svelte.dev/docs/types#app
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};

=======================
File: app.html
=======================
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>

=======================
File: complete_output.sh
=======================
#!/bin/bash



# Run script1.sh and script2.sh
./show_tree.sh 
./repo_to_txt.sh

# Optional: Clean up individual output files if not needed
rm "./directory_structure.txt"
=======================
File: directory_structure.txt
=======================

.
â”œâ”€â”€ app.d.ts
â”œâ”€â”€ app.html
â”œâ”€â”€ complete_output.sh
â”œâ”€â”€ directory_structure.txt
lib
applications
â”œâ”€â”€ Calculator.svelte
â”œâ”€â”€ FileExplorer.svelte
â”œâ”€â”€ InternetExplorer.svelte
â”œâ”€â”€ Minesweeper.svelte
â”œâ”€â”€ Notepad.svelte
â”œâ”€â”€ Paint.svelte
â”œâ”€â”€ PlaceholderApp.svelte
â”œâ”€â”€ Settings.svelte
â”œâ”€â”€ Solitaire.svelte
â””â”€â”€ WordPad.svelte
classes
â”œâ”€â”€ Tile.ts
â””â”€â”€ TileManager.ts
components
Desktop
â””â”€â”€ Desktop.svelte
Taskbar
â”œâ”€â”€ MenuItemComponent.svelte
â”œâ”€â”€ StartButton.svelte
â”œâ”€â”€ StartMenu.svelte
â”œâ”€â”€ Taskbar.svelte
â””â”€â”€ TaskbarButton.svelte
Window
â”œâ”€â”€ ResizeHandle.svelte
â”œâ”€â”€ Tile.svelte
â”œâ”€â”€ Titlebar.svelte
â”œâ”€â”€ WindowButtons.svelte
â””â”€â”€ WindowContent.svelte
config
â””â”€â”€ startMenuStructure.ts
stores
â”œâ”€â”€ backgroundColorStore.ts
â””â”€â”€ tilesStore.ts
styles
â””â”€â”€ desktop.css
types
â”œâ”€â”€ StartMenuItem.ts
â””â”€â”€ TileData.ts
utils
â”œâ”€â”€ addTile.ts
â”œâ”€â”€ focusTile.ts
â”œâ”€â”€ focusTopmostTile.ts
â”œâ”€â”€ minimizeTile.ts
â”œâ”€â”€ restoreTile.ts
â””â”€â”€ windowUtils.ts
â”œâ”€â”€ output.txt
â”œâ”€â”€ repo_to_txt.sh
routes
â”œâ”€â”€ +layout.svelte
â”œâ”€â”€ +page.svelte
â”œâ”€â”€ +page.ts
â””â”€â”€ styles.css
â””â”€â”€ show_tree.sh

=======================
File: lib/applications/Calculator.svelte
=======================
<script lang="ts">
    let display = '0';
    let currentOperation = '';
    let previousValue = 0;
  
    function handleButtonClick(value: string) {
      if (value === 'C') {
        display = '0';
        currentOperation = '';
        previousValue = 0;
      } else if (value === '=') {
        calculate();
      } else if (['+', '-', '*', '/'].includes(value)) {
        currentOperation = value;
        previousValue = parseFloat(display);
        display = '0';
      } else {
        display = display === '0' ? value : display + value;
      }
    }
  
    function calculate() {
      const currentValue = parseFloat(display);
      let result = 0;
      switch (currentOperation) {
        case '+':
          result = previousValue + currentValue;
          break;
        case '-':
          result = previousValue - currentValue;
          break;
        case '*':
          result = previousValue * currentValue;
          break;
        case '/':
          result = previousValue / currentValue;
          break;
      }
      display = result.toString();
      currentOperation = '';
    }
  </script>
  
  <div class="calculator">
    <div class="display">{display}</div>
    <div class="buttons">
      {#each ['7', '8', '9', '/', '4', '5', '6', '*', '1', '2', '3', '-', '0', 'C', '=', '+'] as button}
        <button on:click={() => handleButtonClick(button)}>{button}</button>
      {/each}
    </div>
  </div>
  
  <style>
    .calculator {
      width: 200px;
      margin: 10px auto;
      background-color: #d4d0c8;
      border: 2px solid #808080;
      border-top-color: #ffffff;
      border-left-color: #ffffff;
    }
    .display {
      background-color: #ffffff;
      border: 1px solid #808080;
      margin: 5px;
      padding: 5px;
      text-align: right;
      font-family: 'Courier New', monospace;
    }
    .buttons {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2px;
      padding: 5px;
    }
    button {
      background-color: #d4d0c8;
      border: 2px solid #808080;
      border-top-color: #ffffff;
      border-left-color: #ffffff;
      padding: 5px;
      font-family: 'Tahoma', sans-serif;
      font-size: 12px;
    }
    button:active {
      border: 2px solid #808080;
      border-bottom-color: #ffffff;
      border-right-color: #ffffff;
    }
  </style>
=======================
File: lib/applications/FileExplorer.svelte
=======================
<script lang="ts">
    import PlaceholderApp from './PlaceholderApp.svelte';
  </script>
  
  <PlaceholderApp title="File Explorer" />
=======================
File: lib/applications/InternetExplorer.svelte
=======================
<script lang="ts">
    import PlaceholderApp from './PlaceholderApp.svelte';
  </script>
  
  <PlaceholderApp title="Internet Explorer" />
=======================
File: lib/applications/Minesweeper.svelte
=======================
<script lang="ts">
    let grid: number[][] = [];
    let revealed: boolean[][] = [];
    const size = 9;
    const mines = 10;
  
    function initializeGrid() {
      grid = Array(size).fill(null).map(() => Array(size).fill(0));
      revealed = Array(size).fill(null).map(() => Array(size).fill(false));
      
      // Place mines
      let minesPlaced = 0;
      while (minesPlaced < mines) {
        const x = Math.floor(Math.random() * size);
        const y = Math.floor(Math.random() * size);
        if (grid[y][x] !== -1) {
          grid[y][x] = -1;
          minesPlaced++;
        }
      }
  
      // Calculate numbers
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (grid[y][x] === -1) continue;
          grid[y][x] = countAdjacentMines(x, y);
        }
      }
    }
  
    function countAdjacentMines(x: number, y: number): number {
      let count = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const ny = y + dy;
          const nx = x + dx;
          if (ny >= 0 && ny < size && nx >= 0 && nx < size && grid[ny][nx] === -1) {
            count++;
          }
        }
      }
      return count;
    }
  
    function handleClick(x: number, y: number) {
      if (revealed[y][x]) return;
      revealed[y][x] = true;
      if (grid[y][x] === 0) {
        revealAdjacent(x, y);
      }
    }
  
    function revealAdjacent(x: number, y: number) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const ny = y + dy;
          const nx = x + dx;
          if (ny >= 0 && ny < size && nx >= 0 && nx < size && !revealed[ny][nx]) {
            revealed[ny][nx] = true;
            if (grid[ny][nx] === 0) {
              revealAdjacent(nx, ny);
            }
          }
        }
      }
    }
  
    initializeGrid();
  </script>
  
  <div class="minesweeper">
    <div class="grid">
      {#each grid as row, y}
        <div class="row">
          {#each row as cell, x}
            <button class="cell" on:click={() => handleClick(x, y)} disabled={revealed[y][x]}>
              {#if revealed[y][x]}
                {cell === -1 ? 'ðŸ’£' : cell || ''}
              {/if}
            </button>
          {/each}
        </div>
      {/each}
    </div>
  </div>
  
  <style>
    .minesweeper {
      font-family: 'Tahoma', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
    }
    .grid {
      display: inline-block;
      background-color: #c0c0c0;
      border: 2px solid #808080;
      border-top-color: #ffffff;
      border-left-color: #ffffff;
    }
    .row {
      display: flex;
    }
    .cell {
      width: 20px;
      height: 20px;
      border: 1px solid #808080;
      background-color: #c0c0c0;
      font-weight: bold;
      font-size: 12px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
    }
    .cell:disabled {
      background-color: #d3d3d3;
      border: 1px solid #a9a9a9;
    }
  </style>
=======================
File: lib/applications/Notepad.svelte
=======================
<script lang="ts">
    let text = '';
  </script>
  
  <div class="notepad">
    <textarea bind:value={text} placeholder="Type your text here..."></textarea>
  </div>
  
  <style>
    .notepad {
      width: 100%;
      height: 100%;
      padding: 5px;
      box-sizing: border-box;
    }
    textarea {
      width: 100%;
      height: 100%;
      resize: none;
      border: 1px solid #808080;
      background-color: #ffffff;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      padding: 5px;
      box-sizing: border-box;
    }
  </style>
=======================
File: lib/applications/Paint.svelte
=======================
<script lang="ts">
    import PlaceholderApp from './PlaceholderApp.svelte';
  </script>
  
  <PlaceholderApp title="Paint" />
  
=======================
File: lib/applications/PlaceholderApp.svelte
=======================
<script lang="ts">
    export let title: string;
  </script>
  
  <div class="placeholder-app">
    <h2>{title}</h2>
    <p>This application is not yet implemented.</p>
  </div>
  
  <style>
    .placeholder-app {
      padding: 20px;
      text-align: center;
      font-family: 'Tahoma', sans-serif;
    }
    h2 {
      font-size: 16px;
      margin-bottom: 10px;
    }
    p {
      font-size: 12px;
    }
  </style>
  
=======================
File: lib/applications/Settings.svelte
=======================
<script lang="ts">
    import { backgroundColor } from '../stores/backgroundColorStore';
    
    let soundEnabled = true;
    let screenSaverTimeout = 15;
  
    function handleApply() {
      // In a real application, you might want to save these settings to some persistent storage
      console.log('Settings applied');
    }
  </script>
  
  <div class="settings">
    <h2>Display Settings</h2>
    <div class="setting">
      <label for="background-color">Background Color:</label>
      <input type="color" id="background-color" bind:value={$backgroundColor}>
    </div>
  
    <h2>Sound Settings</h2>
    <div class="setting">
      <label>
        <input type="checkbox" bind:checked={soundEnabled}>
        Enable System Sounds
      </label>
    </div>
  
    <h2>Screen Saver</h2>
    <div class="setting">
      <label for="screensaver-timeout">Wait</label>
      <input type="number" id="screensaver-timeout" bind:value={screenSaverTimeout} min="1" max="60">
      <span>minutes</span>
    </div>
  
    <button class="apply-button" on:click={handleApply}>Apply</button>
  </div>
  
  <style>
    .settings {
      padding: 10px;
      font-family: 'Tahoma', sans-serif;
      font-size: 11px;
    }
    h2 {
      font-size: 14px;
      margin-top: 15px;
      margin-bottom: 5px;
      border-bottom: 1px solid #808080;
    }
    .setting {
      margin-bottom: 10px;
    }
    label {
      display: inline-block;
      width: 150px;
    }
    input[type="color"] {
      width: 50px;
      height: 20px;
      border: 1px solid #808080;
    }
    input[type="number"] {
      width: 40px;
    }
    .apply-button {
      background-color: #d4d0c8;
      border: 2px solid #808080;
      border-top-color: #ffffff;
      border-left-color: #ffffff;
      padding: 5px 10px;
      font-family: 'Tahoma', sans-serif;
      font-size: 11px;
      margin-top: 10px;
    }
    .apply-button:active {
      border: 2px solid #808080;
      border-bottom-color: #ffffff;
      border-right-color: #ffffff;
    }
  </style>
=======================
File: lib/applications/Solitaire.svelte
=======================
<script lang="ts">
    import PlaceholderApp from './PlaceholderApp.svelte';
  </script>
  
  <PlaceholderApp title="Solitaire" />
=======================
File: lib/applications/WordPad.svelte
=======================
<script lang="ts">
    let text = '';
  </script>
  
  <div class="wordpad">
    <div class="toolbar">
      <button>Bold</button>
      <button>Italic</button>
      <button>Underline</button>
      <select>
        <option>Arial</option>
        <option>Times New Roman</option>
        <option>Courier New</option>
      </select>
      <select>
        <option>8</option>
        <option>10</option>
        <option>12</option>
        <option>14</option>
        <option>16</option>
      </select>
    </div>
    <textarea bind:value={text} placeholder="Type your text here..."></textarea>
  </div>
  
  <style>
    .wordpad {
      display: flex;
      flex-direction: column;
      height: 100%;
      font-family: 'Tahoma', sans-serif;
    }
    .toolbar {
      display: flex;
      gap: 5px;
      padding: 5px;
      background-color: #d4d0c8;
      border-bottom: 1px solid #808080;
    }
    button, select {
      font-size: 11px;
      padding: 2px 5px;
    }
    textarea {
      flex-grow: 1;
      resize: none;
      border: none;
      padding: 5px;
      font-family: 'Arial', sans-serif;
      font-size: 12px;
    }
  </style>
=======================
File: lib/classes/Tile.ts
=======================
import { tileManager } from './TileManager.ts';
import { 
  calculateWindowPosition, 
  constrainWindowPosition, 
  calculateResizedDimensions 
} from '../utils/windowUtils';


export class Tile {
    private tile: HTMLDivElement;
    private desktop: HTMLDivElement;
    private isDragging: boolean = false;
    private isResizing: boolean = false;
    private startX!: number;
    private startY!: number;
    private initialX!: number;
    private initialY!: number;
    private initialWidth!: number;
    private initialHeight!: number;
    private resizeDirection!: string;
    private onFocus: () => void;
    constructor(tile: HTMLDivElement, desktop: HTMLDivElement, onFocus: () => void) {
        this.tile = tile;
        this.desktop = desktop;
        this.onFocus = onFocus;
        tileManager.registerTile(this.tile);
        this.initializeEventListeners();

        const { x, y } = calculateWindowPosition(this.desktop, this.tile.clientWidth, this.tile.clientHeight);
        this.tile.style.left = `${x}px`;
        this.tile.style.top = `${y}px`;
    }

    private initializeEventListeners() {
        this.tile.addEventListener('mousedown', this.onMouseDown.bind(this));
    }

    public startDragging(event: MouseEvent) {
        this.isDragging = true;
        this.startX = event.clientX;
        this.startY = event.clientY;
        this.initialX = this.tile.offsetLeft;
        this.initialY = this.tile.offsetTop;

        window.addEventListener('mousemove', this.onMouseMove.bind(this));
        window.addEventListener('mouseup', this.onMouseUp.bind(this));
        event.preventDefault();
    }

    public focus() {
        tileManager.bringToFront(this.tile);
        this.onFocus();
    }

    private onMouseDown(event: MouseEvent) {
        this.focus();
        const target = event.target as HTMLElement;
        if (target.classList.contains('resize-handle')) {
            this.isResizing = true;
            this.startX = event.clientX;
            this.startY = event.clientY;
            this.initialWidth = this.tile.clientWidth;
            this.initialHeight = this.tile.clientHeight;
            this.initialX = this.tile.offsetLeft;
            this.initialY = this.tile.offsetTop;
            this.resizeDirection = target.dataset.direction as string;

            window.addEventListener('mousemove', this.onMouseMove.bind(this));
            window.addEventListener('mouseup', this.onMouseUp.bind(this));
            event.preventDefault();
        }
    }

    private onMouseMove(event: MouseEvent) {
        if (this.isDragging) {
            this.handleDragging(event);
        } else if (this.isResizing) {
            this.handleResizing(event);
        }
    }

    private handleDragging(event: MouseEvent) {
        const dx = event.clientX - this.startX;
        const dy = event.clientY - this.startY;

        const { x: newX, y: newY } = constrainWindowPosition(
            this.initialX + dx,
            this.initialY + dy,
            this.tile.clientWidth,
            this.tile.clientHeight,
            this.desktop
        );

        this.tile.style.left = `${newX}px`;
        this.tile.style.top = `${newY}px`;
    }

    private handleResizing(event: MouseEvent) {
        const dx = event.clientX - this.startX;
        const dy = event.clientY - this.startY;

        const { newWidth, newHeight, newX, newY } = calculateResizedDimensions(
            this.resizeDirection,
            this.startX,
            this.startY,
            this.initialWidth,
            this.initialHeight,
            this.initialX,
            this.initialY,
            dx,
            dy,
            this.desktop
        );

        this.tile.style.width = `${newWidth}px`;
        this.tile.style.height = `${newHeight}px`;
        this.tile.style.left = `${newX}px`;
        this.tile.style.top = `${newY}px`;
    }

    private onMouseUp() {
        this.isDragging = false;
        this.isResizing = false;
        window.removeEventListener('mousemove', this.onMouseMove.bind(this));
        window.removeEventListener('mouseup', this.onMouseUp.bind(this));
    }
}
=======================
File: lib/classes/TileManager.ts
=======================
class TileManager {
    private static instance: TileManager;
    private tiles: HTMLDivElement[] = [];
  
    private constructor() {}
  
    public static getInstance(): TileManager {
      if (!TileManager.instance) {
        TileManager.instance = new TileManager();
      }
      return TileManager.instance;
    }
  
    public registerTile(tile: HTMLDivElement) {
      this.tiles.push(tile);
      this.reindexTiles();
    }
  
    public bringToFront(tile: HTMLDivElement) {
      this.tiles = this.tiles.filter(t => t !== tile);
      this.tiles.push(tile);
      this.reindexTiles();
    }
  
    private reindexTiles() {
      this.tiles.forEach((tile, index) => {
        tile.style.zIndex = String(index + 1);
      });
    }
  }
  
  export const tileManager = TileManager.getInstance();
  
=======================
File: lib/components/Desktop/Desktop.svelte
=======================
<script lang="ts">
    import { onMount } from 'svelte';
    import Taskbar from '../Taskbar/Taskbar.svelte';
    import Tile from '../Window/Tile.svelte';
    import { tilesStore } from '$lib/stores/tilesStore';
    import { backgroundColor } from '$lib/stores/backgroundColorStore';
    import '$lib/styles/desktop.css';
    import type { StartMenuStructure } from '$lib/types/StartMenuItem';
  
    export let startMenuStructure: StartMenuStructure;
  
    let desktop: HTMLDivElement;
  
    function handleStartMenuItemClick(component: string) {
      tilesStore.add(desktop, component);
    }
  
    onMount(() => {
      // Any initialization logic can go here
    });
  </script>
  
  <div class="desktop" bind:this={desktop} style:background-color={$backgroundColor}>
    {#each $tilesStore as tile (tile.id)}
      <Tile 
        {...tile}
        {desktop}
        on:focus={() => tilesStore.focus(tile.id)}
        on:minimize={() => tilesStore.minimize(tile.id)}
        on:close={() => tilesStore.close(tile.id)}
      />
    {/each}
    <Taskbar 
      {startMenuStructure}
      on:menuItemClick={({ detail }) => handleStartMenuItemClick(detail)}
    />
  </div>
  
  <style>
    .desktop {
      width: 100%;
      height: 100vh;
      position: relative;
      overflow: hidden;
    }
  </style>
=======================
File: lib/components/Taskbar/MenuItemComponent.svelte
=======================
<script lang="ts">
    import { createEventDispatcher } from 'svelte';
    import type { StartMenuItem } from '$lib/types/StartMenuItem';
  
    export let item: StartMenuItem;
  
    const dispatch = createEventDispatcher();
  
    function handleClick() {
      if (item.component) {
        dispatch('menuItemClick', item.component);
      }
    }
  </script>
  
  <div class="menu-item" class:has-submenu={item.items && item.items.length > 0}>
    <span on:click={handleClick}>{item.name}</span>
    {#if item.items && item.items.length > 0}
      <div class="submenu">
        {#each item.items as subItem}
          <svelte:self item={subItem} on:menuItemClick />
        {/each}
      </div>
    {/if}
  </div>
  
  <style>
    .menu-item {
      position: relative;
      padding: 4px 8px;
      cursor: pointer;
      font-family: 'Tahoma', sans-serif;
      font-size: 11px;
    }
  
    .menu-item:hover {
      background-color: #000080;
      color: white;
    }
  
    .has-submenu::after {
      content: 'â–¶';
      position: absolute;
      right: 8px;
      font-size: 8px;
    }
  
    .submenu {
      display: none;
      position: absolute;
      left: 100%;
      top: 0;
      background-color: #D4D0C8;
      border: 1px solid #808080;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
    }
  
    .menu-item:hover > .submenu {
      display: block;
    }
  </style>
=======================
File: lib/components/Taskbar/StartButton.svelte
=======================

<script lang="ts">
  import { createEventDispatcher } from 'svelte';

  const dispatch = createEventDispatcher();

  function handleClick() {
    dispatch('click');
  }
</script>

<button class="start-button" on:click={handleClick}>Start</button>

<style>
  .start-button {
    background: linear-gradient(to bottom, #1fdf25, #0a9710);
    border: 2px solid #ffffff;
    border-right-color: #808080;
    border-bottom-color: #808080;
    color: white;
    font-weight: bold;
    font-size: 11px;
    padding: 2px 5px;
    cursor: pointer;
    display: flex;
    align-items: center;
    height: 22px;
    margin-right: 4px;
  }

  .start-button:before {
    content: '';
    display: inline-block;
    width: 16px;
    height: 16px;
    background-color: #008080;
    margin-right: 4px;
  }

  .start-button:active {
    border: 2px solid #808080;
    border-right-color: #ffffff;
    border-bottom-color: #ffffff;
  }
</style>
=======================
File: lib/components/Taskbar/StartMenu.svelte
=======================
<!-- File: lib/components/Taskbar/StartMenu.svelte -->
<script lang="ts">
  import type { StartMenuStructure } from '$lib/types/StartMenuItem';
  import { createEventDispatcher } from 'svelte';
  import MenuItemComponent from './MenuItemComponent.svelte';

  export let menuStructure: StartMenuStructure;
  export let visible: boolean = false;
  
  const dispatch = createEventDispatcher();

  function handleMenuItemClick(event: CustomEvent<string>) {
    dispatch('menuItemClick', event.detail);
  }
</script>

<div class="start-menu" class:visible>
  {#each menuStructure.items as item}
    <MenuItemComponent {item} on:menuItemClick={handleMenuItemClick} />
  {/each}
</div>

<style>
  .start-menu {
    position: absolute;
    bottom: 28px;
    left: 2px;
    width: 200px;
    background-color: #D4D0C8;
    border: 2px solid #808080;
    border-bottom: none;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
    display: none;
    z-index: 10001;
  }

  .start-menu.visible {
    display: block;
  }
</style>
=======================
File: lib/components/Taskbar/Taskbar.svelte
=======================
<script lang="ts">
  import { createEventDispatcher, onMount } from 'svelte';
  import StartButton from './StartButton.svelte';
  import StartMenu from './StartMenu.svelte';
  import TaskbarButton from './TaskbarButton.svelte';
  import { tilesStore } from '$lib/stores/tilesStore';
  import type { StartMenuStructure } from '$lib/types/StartMenuItem';

  const dispatch = createEventDispatcher();

  export let startMenuStructure: StartMenuStructure;

  let isStartMenuVisible: boolean = false;

  function toggleStartMenu(): void {
    isStartMenuVisible = !isStartMenuVisible;
  }

  function handleClickOutside(event: MouseEvent): void {
    const startMenu = document.querySelector('.start-menu') as HTMLElement;
    const startButton = document.querySelector('.start-button') as HTMLElement;

    if (startMenu && startButton && !startButton.contains(event.target as Node)) {
      isStartMenuVisible = false;
    }
  }

  function handleMenuItemClick(event: CustomEvent<string>) {
    dispatch('menuItemClick', event.detail);
    isStartMenuVisible = false;
  }

  function handleWindowClick(id: number, isMinimized: boolean) {
    if (isMinimized) {
      tilesStore.restore(id);
    } else {
      tilesStore.focus(id);
    }
  }

  onMount(() => {
    document.addEventListener('click', handleClickOutside);
    return () => {
      document.removeEventListener('click', handleClickOutside);
    };
  });
</script>

<div class="taskbar">
  <StartButton on:click={toggleStartMenu} />
  <div class="window-tabs">
    {#each $tilesStore as tile (tile.id)}
      <TaskbarButton
        title={tile.title}
        isFocused={tile.isFocused}
        isMinimized={tile.isMinimized}
        on:click={() => handleWindowClick(tile.id, tile.isMinimized)}
      />
    {/each}
  </div>
</div>

<StartMenu
  menuStructure={startMenuStructure}
  visible={isStartMenuVisible}
  on:menuItemClick={handleMenuItemClick}
/>

<style>
  .taskbar {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 28px;
    background-color: #d4d0c8;
    display: flex;
    align-items: center;
    padding: 0 2px;
    border-top: 2px solid #ffffff;
    box-sizing: border-box;
    z-index: 10000;
  }

  .window-tabs {
    display: flex;
    flex-grow: 1;
    overflow-x: auto;
    height: 100%;
  }
</style>

=======================
File: lib/components/Taskbar/TaskbarButton.svelte
=======================

<script lang="ts">
  export let title: string;
  export let isFocused: boolean;
  export let isMinimized: boolean;
</script>

<div
  class="window-tab"
  class:focused={isFocused}
  class:minimized={isMinimized}
  on:click
>
  {title}
</div>

<style>
  .window-tab {
    background-color: #d4d0c8;
    border: 1px solid #808080;
    border-bottom: none;
    padding: 2px 8px;
    margin-right: 2px;
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 150px;
    height: 22px;
    display: flex;
    align-items: center;
    font-family: 'Tahoma', sans-serif;
    font-size: 11px;
  }

  .window-tab.focused {
    background-color: #ffffff;
    border-top: 2px solid #ffffff;
    border-left: 2px solid #ffffff;
    border-right: 2px solid #808080;
  }

  .window-tab.minimized {
    background-color: #a0a0a0;
  }
</style>
=======================
File: lib/components/Window/ResizeHandle.svelte
=======================
<script lang="ts">
  export let direction: string;
</script>

<style>
  .resize-handle {
    position: absolute;
    background: transparent;
  }

  .resize-handle:hover {
    background: #95a5a6;
  }

  .resize-handle[data-direction*='top'] {
    top: -5px;
    height: 10px;
  }

  .resize-handle[data-direction*='bottom'] {
    bottom: -5px;
    height: 10px;
  }

  .resize-handle[data-direction*='left'] {
    left: -5px;
    width: 10px;
  }

  .resize-handle[data-direction*='right'] {
    right: -5px;
    width: 10px;
  }

  .resize-handle[data-direction='top-left'] {
    cursor: nwse-resize;
    width: 10px;
    height: 10px;
  }

  .resize-handle[data-direction='top-right'] {
    cursor: nesw-resize;
    width: 10px;
    height: 10px;
  }

  .resize-handle[data-direction='bottom-left'] {
    cursor: nesw-resize;
    width: 10px;
    height: 10px;
  }

  .resize-handle[data-direction='bottom-right'] {
    cursor: nwse-resize;
    width: 10px;
    height: 10px;
  }

  .resize-handle[data-direction='top'] {
    cursor: ns-resize;
    width: 100%;
  }

  .resize-handle[data-direction='bottom'] {
    cursor: ns-resize;
    width: 100%;
  }

  .resize-handle[data-direction='left'] {
    cursor: ew-resize;
    height: 100%;
  }

  .resize-handle[data-direction='right'] {
    cursor: ew-resize;
    height: 100%;
  }
</style>

<div
  class="resize-handle"
  data-direction={direction}
  on:mousedown
></div>

=======================
File: lib/components/Window/Tile.svelte
=======================

<script lang="ts">
  import { onMount, createEventDispatcher } from 'svelte';
  import ResizeHandle from './ResizeHandle.svelte';
  import Titlebar from './Titlebar.svelte';
  import WindowContent from './WindowContent.svelte';
  import { Tile as TileClass } from '$lib/classes/Tile';
  import type { TileData } from '$lib/types/TileData';

  export let desktop: HTMLDivElement;
  export let id: number;
  export let x: number;
  export let y: number;
  export let title: string;
  export let isFocused: boolean;
  export let isMinimized: boolean = false;
  export let zIndex: number;

  const dispatch = createEventDispatcher();

  let tile: HTMLDivElement;
  let tileInstance: TileClass;

  const directions = [
    'top-left', 'top-right', 'bottom-left', 'bottom-right',
    'top', 'bottom', 'left', 'right'
  ];

  onMount(() => {
    tileInstance = new TileClass(tile, desktop, () => dispatch('focus', id));
    tile.style.left = `${x}px`;
    tile.style.top = `${y}px`;
  });

  function handleMouseDown(event: MouseEvent) {
    const titlebar = tile.querySelector('.titlebar');
    if (titlebar && titlebar.contains(event.target as Node)) {
      tileInstance.startDragging(event);
    }
    tileInstance.focus();
  }

  function handleTitlebarAction(event: CustomEvent) {
    dispatch(event.type, id);
  }

  $: tile && (tile.style.zIndex = zIndex.toString());
</script>

<div class="tile" class:focused={isFocused} class:minimized={isMinimized} bind:this={tile} on:mousedown={handleMouseDown}>
  <Titlebar {title} {isFocused} 
    on:minimize={handleTitlebarAction}
    on:maximize={handleTitlebarAction}
    on:close={handleTitlebarAction}
  />
  <WindowContent {title} />
  {#each directions as direction}
    <ResizeHandle {direction} />
  {/each}
</div>

<style>
  .tile {
    width: 300px;
    height: 200px;
    background-color: #D4D0C8;
    position: absolute;
    top: 0;
    left: 0;
    display: flex;
    flex-direction: column;
    min-width: 100px;
    min-height: 100px;
    max-width: 500px;
    max-height: 500px;
    user-select: none;
    border: 2px solid #ffffff;
    border-right-color: #808080;
    border-bottom-color: #808080;
    box-shadow: 1px 1px 0 #000000;
  }

  .tile.minimized {
    display: none;
  }

  .tile.focused {
    z-index: 100;
  }
</style>
=======================
File: lib/components/Window/Titlebar.svelte
=======================


<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  import WindowButtons from './WindowButtons.svelte';

  export let title: string;
  export let isFocused: boolean;

  const dispatch = createEventDispatcher();

  function handleButtonAction(event: CustomEvent) {
    dispatch(event.type, event.detail);
  }
</script>

<div class="titlebar" class:focused={isFocused}>
  <div class="title">{title}</div>
  <WindowButtons 
    on:minimize={handleButtonAction}
    on:maximize={handleButtonAction}
    on:close={handleButtonAction}
  />
</div>

<style>
  .titlebar {
    height: 18px;
    background: linear-gradient(to right, #7b7b7b, #a8a8a8);
    color: #d8d8d8;
    font-weight: bold;
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 2px 3px;
    cursor: move;
  }

  .titlebar.focused {
    background: linear-gradient(to right, #000080, #1084d0);
    color: white;
  }
</style>
=======================
File: lib/components/Window/WindowButtons.svelte
=======================


<script lang="ts">
  import { createEventDispatcher } from 'svelte';

  const dispatch = createEventDispatcher();

  function handleMinimize() {
    dispatch('minimize');
  }

  function handleMaximize() {
    dispatch('maximize');
  }

  function handleClose() {
    dispatch('close');
  }
</script>

<div class="buttons">
  <button class="minimize" on:click={handleMinimize}>_</button>
  <button class="maximize" on:click={handleMaximize}>â–¡</button>
  <button class="close" on:click={handleClose}>X</button>
</div>

<style>
  .buttons {
    display: flex;
  }

  .buttons button {
    width: 16px;
    height: 14px;
    margin-left: 2px;
    border: 1px solid #ffffff;
    background-color: #D4D0C8;
    color: #000000;
    font-size: 9px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
  }
</style>
=======================
File: lib/components/Window/WindowContent.svelte
=======================
<script lang="ts">
  import Calculator from '../../applications/Calculator.svelte';
  import Notepad from '../../applications/Notepad.svelte';
  import Settings from '../../applications/Settings.svelte';
  import Paint from '../../applications/Paint.svelte';
  import FileExplorer from '../../applications/FileExplorer.svelte';
  import InternetExplorer from '../../applications/InternetExplorer.svelte';
  import Minesweeper from '../../applications/Minesweeper.svelte';
  import Solitaire from '../../applications/Solitaire.svelte';
  import WordPad from '../../applications/WordPad.svelte';

  export let title: string;
</script>

<div class="body">
  {#if title === 'Calculator'}
    <Calculator />
  {:else if title === 'Notepad'}
    <Notepad />
  {:else if title === 'Settings'}
    <Settings />
  {:else if title === 'Paint'}
    <Paint />
  {:else if title === 'File Explorer'}
    <FileExplorer />
  {:else if title === 'Internet Explorer'}
    <InternetExplorer />
  {:else if title === 'Minesweeper'}
    <Minesweeper />
  {:else if title === 'Solitaire'}
    <Solitaire />
  {:else if title === 'WordPad'}
    <WordPad />
  {:else}
    <p>Window Content for {title}</p>
  {/if}
</div>

<style>
  .body {
    width: 100%;
    height: calc(100% - 22px);
    background-color: #ffffff;
    flex: 1;
    border: 1px solid #808080;
    border-top-color: #ffffff;
    padding: 2px;
    font-family: 'Tahoma', sans-serif;
    font-size: 11px;
    overflow: auto;
  }
</style>
=======================
File: lib/config/startMenuStructure.ts
=======================
// File: lib/config/startMenuStructure.ts

import type { StartMenuStructure } from '$lib/types/StartMenuItem';

const startMenuStructure: StartMenuStructure = {
  name: 'Start',
  items: [
    {
      name: "Programs",
      items: [
        {
          name: "Accessories",
          items: [
            { name: "Calculator", component: "Calculator", items: [] },
            { name: "Notepad", component: "Notepad", items: [] },
            { name: "Paint", component: "Paint", items: [] },
            { name: "WordPad", component: "WordPad", items: [] }
          ]
        },
        { name: "Internet Explorer", component: "InternetExplorer", items: [] },
        { name: "Minesweeper", component: "Minesweeper", items: [] },
        { name: "Solitaire", component: "Solitaire", items: [] }
      ]
    },
    {
      name: "Documents",
      items: []
    },
    {
      name: "Settings",
      items: [
        { name: "Control Panel", component: "PlaceholderApp", items: [] },
        { name: "Printers", component: "PlaceholderApp", items: [] }
      ]
    },
    {
      name: "Find",
      items: [
        { name: "Files or Folders...", component: "PlaceholderApp", items: [] },
        { name: "Computer...", component: "PlaceholderApp", items: [] }
      ]
    },
    { name: "Help", component: "PlaceholderApp", items: [] },
    { name: "Run...", component: "PlaceholderApp", items: [] },
    { name: "Shut Down...", component: "PlaceholderApp", items: [] }
  ]
};

export default startMenuStructure;
=======================
File: lib/stores/backgroundColorStore.ts
=======================
import { writable } from 'svelte/store';

export const backgroundColor = writable('#008080');
=======================
File: lib/stores/tilesStore.ts
=======================
import { writable } from 'svelte/store';
import type { TileData } from '../types/TileData';
import { addTile } from '../utils/addTile';
import { focusTile } from '../utils/focusTile';
import { minimizeTile } from '../utils/minimizeTile';
import { restoreTile } from '../utils/restoreTile';
import { focusTopmostTile } from '../utils/focusTopmostTile';

function createTilesStore() {
    const { subscribe, update } = writable<TileData[]>([]);
    let nextTileId = 0;

    return {
        subscribe,
        add: (desktop: HTMLDivElement, title: string) => update(tiles => 
            addTile(tiles, nextTileId++, desktop, title)
        ),
        focus: (id: number) => update(tiles => 
            focusTile(tiles, id)
        ),
        minimize: (id: number) => update(tiles => 
            minimizeTile(tiles, id)
        ),
        restore: (id: number) => update(tiles => 
            restoreTile(tiles, id)
        ),
        close: (id: number) => update(tiles => {
            const updatedTiles = tiles.filter(tile => tile.id !== id);
            return focusTopmostTile(updatedTiles);
        }),
        focusTopmost: () => update(focusTopmostTile)
    };
}

export const tilesStore = createTilesStore();
=======================
File: lib/styles/desktop.css
=======================
.desktop {
  width: 100%;
  height: 100vh;
  position: relative;
  overflow: hidden;
}
=======================
File: lib/types/StartMenuItem.ts
=======================
export interface StartMenuItem {
    name: string;
    component?: string;
    items: StartMenuItem[];
  }
  
  export interface StartMenuItemWithOptionalItems {
    name: string;
    component?: string;
    items?: StartMenuItemWithOptionalItems[];
  }
  
  export interface StartMenuStructure {
    name: string;
    items: StartMenuItem[];
  }
=======================
File: lib/types/TileData.ts
=======================
export interface TileData {
    id: number;
    x: number;
    y: number;
    title: string;
    isFocused: boolean;
    isMinimized: boolean;
    zIndex: number;
}
=======================
File: lib/utils/addTile.ts
=======================
// File: lib/utils/addTile.ts

import type { TileData } from '../types/TileData';

export function addTile(tiles: TileData[], nextTileId: number, desktop: HTMLDivElement, title: string): TileData[] {
    const desktopRect = desktop.getBoundingClientRect();
    const tileWidth = 300;
    const tileHeight = 200;

    const maxX = desktopRect.width - tileWidth;
    const maxY = desktopRect.height - tileHeight - 28;
    const x = Math.floor(Math.random() * maxX);
    const y = Math.floor(Math.random() * maxY);

    const maxZIndex = Math.max(0, ...tiles.map(tile => tile.zIndex));

    const newTile: TileData = { 
        id: nextTileId, 
        x, 
        y, 
        title, 
        isFocused: true, 
        isMinimized: false, 
        zIndex: maxZIndex + 1 
    };
    return [...tiles.map(tile => ({ ...tile, isFocused: false })), newTile];
}
=======================
File: lib/utils/focusTile.ts
=======================
import type { TileData } from '../types/TileData';

export function focusTile(tiles: TileData[], id: number): TileData[] {
    const maxZIndex = Math.max(...tiles.map(tile => tile.zIndex));
    return tiles.map(tile => ({
        ...tile,
        isFocused: tile.id === id && !tile.isMinimized,
        zIndex: tile.id === id ? maxZIndex + 1 : tile.zIndex
    }));
}
=======================
File: lib/utils/focusTopmostTile.ts
=======================
// File: lib/utils/focusTopmostTile.ts

import type { TileData } from '../types/TileData';

export function focusTopmostTile(tiles: TileData[]): TileData[] {
    const visibleTiles = tiles.filter(tile => !tile.isMinimized);
    if (visibleTiles.length === 0) return tiles;
    
    const maxZIndex = Math.max(...visibleTiles.map(tile => tile.zIndex));
    const topmostTileId = visibleTiles.find(tile => tile.zIndex === maxZIndex)!.id;
    
    return tiles.map(tile => ({
        ...tile,
        isFocused: tile.id === topmostTileId,
        zIndex: tile.id === topmostTileId ? maxZIndex + 1 : tile.zIndex
    }));
}
=======================
File: lib/utils/minimizeTile.ts
=======================
// File: lib/utils/minimizeTile.ts

import type { TileData } from '../types/TileData';
import { focusTopmostTile } from './focusTopmostTile';

export function minimizeTile(tiles: TileData[], id: number): TileData[] {
    const updatedTiles = tiles.map(tile => 
        tile.id === id ? { ...tile, isMinimized: true, isFocused: false } : tile
    );
    return focusTopmostTile(updatedTiles);
}
=======================
File: lib/utils/restoreTile.ts
=======================
// File: lib/utils/restoreTile.ts

import type { TileData } from '../types/TileData';

export function restoreTile(tiles: TileData[], id: number): TileData[] {
    const maxZIndex = Math.max(...tiles.map(tile => tile.zIndex));
    return tiles.map(tile => 
        tile.id === id 
            ? { ...tile, isMinimized: false, isFocused: true, zIndex: maxZIndex + 1 } 
            : { ...tile, isFocused: false }
    );
}
=======================
File: lib/utils/windowUtils.ts
=======================
// src/lib/utils/windowUtils.ts

export function calculateWindowPosition(desktop: HTMLElement, width: number, height: number) {
    const desktopRect = desktop.getBoundingClientRect();
    const maxX = desktopRect.width - width;
    const maxY = desktopRect.height - height - 28; // Subtract taskbar height
  
    const x = Math.floor(Math.random() * maxX);
    const y = Math.floor(Math.random() * maxY);
  
    return { x, y };
  }
  
  export function constrainWindowPosition(
    x: number,
    y: number,
    width: number,
    height: number,
    desktop: HTMLElement
  ) {
    const desktopRect = desktop.getBoundingClientRect();
    const maxX = desktopRect.width - width;
    const maxY = desktopRect.height - height - 28; // Subtract taskbar height
  
    return {
      x: Math.max(0, Math.min(x, maxX)),
      y: Math.max(0, Math.min(y, maxY)),
    };
  }
  
  export function calculateResizedDimensions(
    direction: string,
    startX: number,
    startY: number,
    initialWidth: number,
    initialHeight: number,
    initialX: number,
    initialY: number,
    dx: number,
    dy: number,
    desktop: HTMLElement
  ) {
    const desktopRect = desktop.getBoundingClientRect();
    const minWidth = 100;
    const minHeight = 100;
    const maxWidth = 500;
    const maxHeight = 500;
  
    let newWidth = initialWidth;
    let newHeight = initialHeight;
    let newX = initialX;
    let newY = initialY;
  
    if (direction.includes('right')) {
      newWidth = Math.min(
        Math.max(minWidth, initialWidth + dx),
        desktopRect.width - initialX,
        maxWidth
      );
    }
    if (direction.includes('bottom')) {
      newHeight = Math.min(
        Math.max(minHeight, initialHeight + dy),
        desktopRect.height - initialY - 28,
        maxHeight
      );
    }
    if (direction.includes('left')) {
      const maxLeftMove = Math.min(initialWidth - minWidth, initialX);
      const leftMove = Math.max(-maxLeftMove, Math.min(dx, initialWidth - minWidth));
      newWidth = Math.min(initialWidth - leftMove, maxWidth);
      newX = initialX + initialWidth - newWidth;
    }
    if (direction.includes('top')) {
      const maxTopMove = Math.min(initialHeight - minHeight, initialY);
      const topMove = Math.max(-maxTopMove, Math.min(dy, initialHeight - minHeight));
      newHeight = Math.min(initialHeight - topMove, maxHeight);
      newY = initialY + initialHeight - newHeight;
    }
  
    return { newWidth, newHeight, newX, newY };
  }
=======================
File: output.txt
=======================

=======================
File: repo_to_txt.sh
=======================
#!/bin/bash

# Directory containing the files
DIR="."
# Output file
OUTPUT="output.txt"
# Clear the output file if it exists
> "$OUTPUT"

# Find all files in the directory and subdirectories, excluding certain file types
find "$DIR" -type f ! \( -name '*.svg' -o -name '*.png' -o -name '*.jpg' -o -name '*.jpeg' -o -name '*.webp' -o -name '*.gif' -o -name '*.bmp' \) | while read -r FILE; do
    # Get the filename
    FILENAME=$(basename "$FILE")
    # Get the relative path (remove the leading "./" if present)
    RELPATH=$(dirname "$FILE" | sed 's|^\./||')
    
    # Add a banner with the filename and its path
    echo "=======================" >> "$OUTPUT"
    if [ "$RELPATH" = "." ]; then
        echo "File: $FILENAME" >> "$OUTPUT"
    else
        echo "File: $RELPATH/$FILENAME" >> "$OUTPUT"
    fi
    echo "=======================" >> "$OUTPUT"
    
    # Append the contents of each file to the output file
    cat "$FILE" >> "$OUTPUT"
    echo >> "$OUTPUT"  # Add a newline for separation
done

echo "All files have been concatenated into $OUTPUT"
=======================
File: routes/+layout.svelte
=======================
<script>
</script>

<div >


	<main>
		<slot />
	</main>


</div>


=======================
File: routes/+page.svelte
=======================
<script lang="ts">
  import Desktop from '$lib/components/Desktop/Desktop.svelte';
  import startMenuStructure from '$lib/config/startMenuStructure';
</script>

<Desktop {startMenuStructure} />
=======================
File: routes/+page.ts
=======================
// since there's no dynamic data here, we can prerender
// it so that it gets served as a static asset in production
export const prerender = true;

=======================
File: routes/styles.css
=======================

=======================
File: show_tree.sh
=======================
#!/bin/bash

output_file="directory_structure.txt"

# Function to recursively print directory structure
print_tree() {
    local current_dir="$1"
    local indent="$2"
    local is_last="$3"
    local prefix=""

    if [ "$indent" != "" ]; then
        prefix="$indent"
        if [ "$is_last" = true ]; then
            prefix+="â””â”€â”€ "
            indent+="    "
        else
            prefix+="â”œâ”€â”€ "
            indent+="â”‚   "
        fi
    fi

    echo "${prefix}$(basename "$current_dir")" >> "$output_file"

    local items=("$current_dir"/*)
    local total_items=${#items[@]}
    local count=1

    for item in "${items[@]}"; do
        if [ -d "$item" ]; then
            print_tree "$item" "$indent" $(( count == total_items ))
        else
            if [ $count -eq $total_items ]; then
                echo "${indent}â””â”€â”€ $(basename "$item")" >> "$output_file"
            else
                echo "${indent}â”œâ”€â”€ $(basename "$item")" >> "$output_file"
            fi
        fi
        ((count++))
    done
}

# Clear the output file
echo "" > "$output_file"

# Start printing from the current directory
print_tree "." "" true

echo "Directory structure has been written to $output_file"

