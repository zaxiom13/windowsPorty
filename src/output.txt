=======================
File: app.d.ts
=======================
// See https://kit.svelte.dev/docs/types#app
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};

=======================
File: app.html
=======================
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>

=======================
File: complete_output.sh
=======================
#!/bin/bash



# Run script1.sh and script2.sh
./show_tree.sh 
./repo_to_txt.sh

# Optional: Clean up individual output files if not needed
rm "./directory_structure.txt"
=======================
File: directory_structure.txt
=======================

.
├── app.d.ts
├── app.html
├── complete_output.sh
├── directory_structure.txt
lib
images
├── github.svg
├── svelte-logo.svg
├── svelte-welcome.png
└── svelte-welcome.webp
├── output.txt
├── repo_to_txt.sh
routes
├── +layout.svelte
├── +page.svelte
├── +page.ts
├── ResizeHandle.svelte
├── StartMenu.svelte
├── styles.css
├── Taskbar.svelte
└── Tile.svelte
├── show_tree.sh
├── Tile.ts
└── window.svelte.ts

=======================
File: output.txt
=======================

=======================
File: repo_to_txt.sh
=======================
#!/bin/bash

# Directory containing the files
DIR="."

# Output file
OUTPUT="output.txt"

# Clear the output file if it exists
> "$OUTPUT"

# Find all files in the directory and subdirectories, excluding certain file types
find "$DIR" -type f ! \( -name '*.svg' -o -name '*.png' -o -name '*.jpg' -o -name '*.jpeg' -o -name '*.webp' -o -name '*.gif' -o -name '*.bmp' \) | while read -r FILE; do
    FILENAME=$(basename "$FILE")
    # Add a banner with the filename
    echo "=======================" >> "$OUTPUT"
    echo "File: $FILENAME" >> "$OUTPUT"
    echo "=======================" >> "$OUTPUT"
    # Append the contents of each file to the output file
    cat "$FILE" >> "$OUTPUT"
    echo >> "$OUTPUT"  # Add a newline for separation
done

echo "All files have been concatenated into $OUTPUT"

=======================
File: +layout.svelte
=======================
<script>
</script>

<div >


	<main>
		<slot />
	</main>


</div>


=======================
File: +page.svelte
=======================
<script lang="ts">
	import { onMount } from 'svelte';
	import Taskbar from './Taskbar.svelte';
	import Tile from './Tile.svelte';
  
	let desktop: HTMLDivElement;
  
	onMount(() => {
	  // Additional setup if necessary
	});
  </script>
  
  <div class="desktop" bind:this={desktop}>
	<Tile {desktop} />
	<Taskbar />
  </div>
  
  <style>
	.desktop {
	  width: 100%;
	  height: 100vh;
	  border: 1px solid #000;
	  position: relative;
	  overflow: hidden;
	}
  </style>
  
=======================
File: +page.ts
=======================
// since there's no dynamic data here, we can prerender
// it so that it gets served as a static asset in production
export const prerender = true;

=======================
File: ResizeHandle.svelte
=======================
<script lang="ts">
  export let direction: string;
</script>

<style>
  .resize-handle {
    position: absolute;
    background: transparent;
  }

  .resize-handle:hover {
    background: #95a5a6;
  }

  .resize-handle[data-direction*='top'] {
    top: -5px;
    height: 10px;
  }

  .resize-handle[data-direction*='bottom'] {
    bottom: -5px;
    height: 10px;
  }

  .resize-handle[data-direction*='left'] {
    left: -5px;
    width: 10px;
  }

  .resize-handle[data-direction*='right'] {
    right: -5px;
    width: 10px;
  }

  .resize-handle[data-direction='top-left'] {
    cursor: nwse-resize;
    width: 10px;
    height: 10px;
  }

  .resize-handle[data-direction='top-right'] {
    cursor: nesw-resize;
    width: 10px;
    height: 10px;
  }

  .resize-handle[data-direction='bottom-left'] {
    cursor: nesw-resize;
    width: 10px;
    height: 10px;
  }

  .resize-handle[data-direction='bottom-right'] {
    cursor: nwse-resize;
    width: 10px;
    height: 10px;
  }

  .resize-handle[data-direction='top'] {
    cursor: ns-resize;
    width: 100%;
  }

  .resize-handle[data-direction='bottom'] {
    cursor: ns-resize;
    width: 100%;
  }

  .resize-handle[data-direction='left'] {
    cursor: ew-resize;
    height: 100%;
  }

  .resize-handle[data-direction='right'] {
    cursor: ew-resize;
    height: 100%;
  }
</style>

<div
  class="resize-handle"
  data-direction={direction}
  on:mousedown
></div>

=======================
File: StartMenu.svelte
=======================
<script lang="ts">
  export let visible: boolean = false;
</script>

<style>
  .start-menu {
      position: absolute;
      bottom: 40px; /* Adjust based on the height of the taskbar */
      left: 10px;
      width: 200px;
      background-color: white;
      border: 1px solid #ccc;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      display: none;
  }

  .start-menu.visible {
      display: block;
  }

  .start-menu div {
      padding: 10px;
      cursor: pointer;
  }

  .start-menu div:hover {
      background-color: #f0f0f0;
  }
</style>

<div class="start-menu {visible ? 'visible' : ''}">
  <!-- Start menu content goes here -->
  <div>Item 1</div>
  <div>Item 2</div>
  <div>Item 3</div>
</div>

=======================
File: styles.css
=======================

=======================
File: Taskbar.svelte
=======================
<script lang="ts">
  import { onMount } from 'svelte';
  import StartMenu from './StartMenu.svelte';

  let isStartMenuVisible: boolean = false;

  function toggleStartMenu(): void {
    isStartMenuVisible = !isStartMenuVisible;
  }

  function handleClickOutside(event: MouseEvent): void {
    const startMenu = document.querySelector('.start-menu') as HTMLElement;
    const startButton = document.querySelector('.start-button') as HTMLElement;

    if (startMenu && startButton && !startButton.contains(event.target as Node)) {
      isStartMenuVisible = false;
    }
  }

  onMount((): () => void => {
    document.addEventListener('click', handleClickOutside);
    return () => {
      document.removeEventListener('click', handleClickOutside);
    };
  });
</script>

<style>
  .taskbar {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 40px;
    background-color: #2c3e50;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 10px;
    color: white;
    box-sizing: border-box;
  }

  .start-button {
    background-color: #3498db;
    border: none;
    color: white;
    padding: 10px 20px;
    cursor: pointer;
    border-radius: 5px;
  }

  .start-button:hover {
    background-color: #2980b9;
  }
</style>

<div class="taskbar">
  <button class="start-button" on:click={toggleStartMenu}>Start</button>
</div>

<StartMenu visible={isStartMenuVisible} />

=======================
File: Tile.svelte
=======================
<script lang="ts">
	import { onMount } from 'svelte';
	import ResizeHandle from './ResizeHandle.svelte';
	import { Tile as TileClass } from './../Tile';
  
	export let desktop: HTMLDivElement;
	let tile: HTMLDivElement;
	let tileInstance: TileClass;
  
	const directions = [
	  'top-left',
	  'top-right',
	  'bottom-left',
	  'bottom-right',
	  'top',
	  'bottom',
	  'left',
	  'right'
	];
  
	onMount(() => {
	  tileInstance = new TileClass(tile, desktop);
	});
  
	function handleMouseLeave() {
	  tileInstance?.handleMouseLeave();
	}
  </script>
  
  <div class="tile" bind:this={tile} on:mouseleave={handleMouseLeave}>
	<div class="titlebar">Title Bar</div>
	<div class="body">Tile Body</div>
	{#each directions as direction}
	  <ResizeHandle {direction} />
	{/each}
  </div>
  
  <style>
	.tile {
	  width: 200px;
	  height: 200px;
	  background-color: #3498db;
	  position: absolute;
	  top: 0;
	  left: 0;
	  display: flex;
	  flex-direction: column;
	  min-width: 100px;
	  min-height: 100px;
	  max-width: 500px;
	  max-height: 500px;
	}
  
	.titlebar:active {
	  cursor: grabbing;
	}
  
	.body {
	  width: 100%;
	  height: calc(100% - 30px);
	  background-color: #ecf0f1;
	  flex: 1;
	}
  </style>
  
=======================
File: show_tree.sh
=======================
#!/bin/bash

output_file="directory_structure.txt"

# Function to recursively print directory structure
print_tree() {
    local current_dir="$1"
    local indent="$2"
    local is_last="$3"
    local prefix=""

    if [ "$indent" != "" ]; then
        prefix="$indent"
        if [ "$is_last" = true ]; then
            prefix+="└── "
            indent+="    "
        else
            prefix+="├── "
            indent+="│   "
        fi
    fi

    echo "${prefix}$(basename "$current_dir")" >> "$output_file"

    local items=("$current_dir"/*)
    local total_items=${#items[@]}
    local count=1

    for item in "${items[@]}"; do
        if [ -d "$item" ]; then
            print_tree "$item" "$indent" $(( count == total_items ))
        else
            if [ $count -eq $total_items ]; then
                echo "${indent}└── $(basename "$item")" >> "$output_file"
            else
                echo "${indent}├── $(basename "$item")" >> "$output_file"
            fi
        fi
        ((count++))
    done
}

# Clear the output file
echo "" > "$output_file"

# Start printing from the current directory
print_tree "." "" true

echo "Directory structure has been written to $output_file"

=======================
File: Tile.ts
=======================
export class Tile {
    private tile: HTMLDivElement;
    private desktop: HTMLDivElement;
    private isDragging: boolean = false;
    private isResizing: boolean = false;
    private startX!: number;
    private startY!: number;
    private initialX!: number;
    private initialY!: number;
    private initialWidth!: number;
    private initialHeight!: number;
    private resizeDirection!: string;
  
    constructor(tile: HTMLDivElement, desktop: HTMLDivElement) {
      this.tile = tile;
      this.desktop = desktop;
      this.initializeEventListeners();
    }
  
    private initializeEventListeners() {
      this.tile.addEventListener('mousedown', this.onMouseDown.bind(this));
    }
  
    private onMouseDown(event: MouseEvent) {
      const target = event.target as HTMLElement;
      if (target.classList.contains('titlebar')) {
        this.isDragging = true;
        this.startX = event.clientX;
        this.startY = event.clientY;
        this.initialX = this.tile.offsetLeft;
        this.initialY = this.tile.offsetTop;
  
        window.addEventListener('mousemove', this.onMouseMove.bind(this));
        window.addEventListener('mouseup', this.onMouseUp.bind(this));
        event.preventDefault();
      } else if (target.classList.contains('resize-handle')) {
        this.isResizing = true;
        this.startX = event.clientX;
        this.startY = event.clientY;
        this.initialWidth = this.tile.clientWidth;
        this.initialHeight = this.tile.clientHeight;
        this.initialX = this.tile.offsetLeft;
        this.initialY = this.tile.offsetTop;
        this.resizeDirection = target.dataset.direction as string;
  
        window.addEventListener('mousemove', this.onResizeMove.bind(this));
        window.addEventListener('mouseup', this.onResizeUp.bind(this));
        event.preventDefault();
      }
    }
  
    private onMouseMove(event: MouseEvent) {
      if (!this.isDragging) return;
  
      const dx = event.clientX - this.startX;
      const dy = event.clientY - this.startY;
  
      let newX = this.initialX + dx;
      let newY = this.initialY + dy;
  
      // Boundary conditions
      const rect = this.desktop.getBoundingClientRect();
      const tileRect = this.tile.getBoundingClientRect();
  
      if (newX < 0) newX = 0;
      if (newY < 0) newY = 0;
      if (newX + tileRect.width > rect.width) newX = rect.width - tileRect.width;
      if (newY + tileRect.height > rect.height) newY = rect.height - tileRect.height;
  
      this.tile.style.left = `${newX}px`;
      this.tile.style.top = `${newY}px`;
    }
  
    private onMouseUp() {
      this.isDragging = false;
      window.removeEventListener('mousemove', this.onMouseMove.bind(this));
      window.removeEventListener('mouseup', this.onMouseUp.bind(this));
    }
  
    private onResizeMove(event: MouseEvent) {
      if (!this.isResizing) return;
  
      const dx = event.clientX - this.startX;
      const dy = event.clientY - this.startY;
  
      let newWidth = this.initialWidth;
      let newHeight = this.initialHeight;
      let newX = this.initialX;
      let newY = this.initialY;
  
      if (this.resizeDirection.includes('right')) {
        newWidth = this.initialWidth + dx;
      }
      if (this.resizeDirection.includes('bottom')) {
        newHeight = this.initialHeight + dy;
      }
      if (this.resizeDirection.includes('left')) {
        newWidth = this.initialWidth - dx;
        newX = this.initialX + dx;
      }
      if (this.resizeDirection.includes('top')) {
        newHeight = this.initialHeight - dy;
        newY = this.initialY + dy;
      }
  
      // Apply min and max width and height
      const minWidth = 100;
      const minHeight = 100;
      const maxWidth = 500;
      const maxHeight = 500;
  
      if (newWidth < minWidth) {
        newWidth = minWidth;
        if (this.resizeDirection.includes('left')) {
          newX = this.initialX + (this.initialWidth - minWidth);
        }
      } else if (newWidth > maxWidth) {
        newWidth = maxWidth;
        if (this.resizeDirection.includes('left')) {
          newX = this.initialX + (this.initialWidth - maxWidth);
        }
      }
  
      if (newHeight < minHeight) {
        newHeight = minHeight;
        if (this.resizeDirection.includes('top')) {
          newY = this.initialY + (this.initialHeight - minHeight);
        }
      } else if (newHeight > maxHeight) {
        newHeight = maxHeight;
        if (this.resizeDirection.includes('top')) {
          newY = this.initialY + (this.initialHeight - maxHeight);
        }
      }
  
      this.tile.style.width = `${newWidth}px`;
      this.tile.style.height = `${newHeight}px`;
      this.tile.style.left = `${newX}px`;
      this.tile.style.top = `${newY}px`;
    }
  
    private onResizeUp() {
      this.isResizing = false;
      window.removeEventListener('mousemove', this.onResizeMove.bind(this));
      window.removeEventListener('mouseup', this.onResizeUp.bind(this));
    }
  
    public handleMouseLeave() {
      this.onResizeUp();
    }
  }
  
=======================
File: window.svelte.ts
=======================
export { Tile } from './Tile';

